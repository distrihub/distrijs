{"version":3,"sources":["../src/index.ts","../src/types.ts","../../../node_modules/.pnpm/@a2a-js+sdk@https+++codeload.github.com+v3g42+a2a-js+tar.gz+51444c9/node_modules/@a2a-js/sdk/dist/chunk-CUGIRVQB.js","../src/encoder.ts","../src/distri-client.ts","../src/agent.ts"],"sourcesContent":["// Core exports\nexport * from './types';\nexport * from './events';\nexport * from './distri-client';\nexport * from './agent';\nexport {\n  convertA2AMessageToDistri,\n  convertA2AStatusUpdateToDistri,\n  convertA2APartToDistri,\n  convertDistriMessageToA2A,\n  convertDistriPartToA2A,\n  extractTextFromDistriMessage,\n  extractToolCallsFromDistriMessage,\n  extractToolResultsFromDistriMessage,\n  decodeA2AStreamEvent,\n  processA2AMessagesData,\n  processA2AStreamData,\n} from './encoder';\n\nexport { uuidv4 } from './distri-client';","// Distri Framework Types - Based on A2A Protocol and SSE\nimport { AgentSkill, Message, Task, TaskArtifactUpdateEvent, TaskStatusUpdateEvent } from '@a2a-js/sdk/client';\nimport { DistriEvent } from './events';\nimport { Agent } from './agent';\n\n/**\n * Message roles supported by Distri\n */\nexport type MessageRole = 'system' | 'assistant' | 'user' | 'tool';\n\n/**\n * Distri-specific message structure with parts\n */\nexport interface DistriMessage {\n  id: string;\n  role: MessageRole;\n  parts: DistriPart[];\n  created_at?: string;\n  step_id?: string;\n  is_final?: boolean;\n}\n\nexport interface AssistantWithToolCalls {\n  id: string;\n  type: 'llm_response';\n  timestamp: number;\n  content: string;\n  tool_calls: any[];\n  step_id?: string;\n  success: boolean;\n  rejected: boolean;\n  is_external: boolean;\n  reason: string | null;\n}\n\nexport interface UseToolsOptions {\n  agent?: Agent;\n  externalTools?: DistriBaseTool[];\n  executionOptions?: ToolExecutionOptions;\n}\n\nexport interface ToolExecutionOptions {\n  autoExecute?: boolean;\n}\n\n\nexport interface ToolResults {\n  id: string;\n  type: 'tool_results';\n  timestamp: number;\n  results: any[];\n  step_id?: string;\n  success: boolean;\n  rejected: boolean;\n  reason: string | null;\n}\n\nexport interface DistriPlan {\n  id: string;\n  type: 'plan';\n  timestamp: number;\n  reasoning: string;\n  steps: PlanStep[];\n}\n\nexport interface BasePlanStep {\n  id: string;\n}\n\nexport interface ThoughtPlanStep extends BasePlanStep {\n  type: 'thought';\n  message: string;\n}\n\nexport interface ActionPlanStep extends BasePlanStep {\n  type: 'action';\n  action: PlanAction;\n}\n\nexport interface CodePlanStep extends BasePlanStep {\n  type: 'code';\n  code: string;\n  language: string;\n}\n\nexport interface FinalResultPlanStep extends BasePlanStep {\n  type: 'final_result';\n  content: string;\n  tool_calls: any[]; // Vec<ToolCall> in Rust\n}\n\n// Action can be either a tool call or an LLM call\nexport interface PlanAction {\n  tool_name?: string;\n  input?: string;\n  prompt?: string;\n  context?: any[];\n  tool_calling_config?: any;\n}\n\nexport type PlanStep = ThoughtPlanStep | ActionPlanStep | CodePlanStep | FinalResultPlanStep;\n\n// Legacy types for backward compatibility\nexport interface LlmPlanStep extends BasePlanStep {\n  type: 'llm_call';\n  prompt: string;\n  context: any[];\n}\n\nexport interface BatchToolCallsStep extends BasePlanStep {\n  type: 'batch_tool_calls';\n  tool_calls: any[];\n}\n\nexport interface ThoughtStep extends BasePlanStep {\n  type: 'thought';\n  message: string;\n}\n\nexport interface ReactStep extends BasePlanStep {\n  type: 'react_step';\n  thought: string;\n  action: string;\n}\n\nexport type DistriStreamEvent = DistriMessage | DistriEvent;\n\n\n\n/**\n * Context required for constructing A2A messages from DistriMessage\n */\nexport interface InvokeContext {\n  thread_id: string;\n  run_id?: string;\n  task_id?: string; // A2A taskId to preserve context\n  getMetadata?: () => any; // Additional metadata to attach to MessageSendParams\n}\n\n/**\n * Distri message parts - equivalent to Rust enum Part\n */\n\nexport type TextPart = { part_type: 'text'; data: string }\nexport type ToolCallPart = { part_type: 'tool_call'; data: ToolCall }\nexport type ToolResultRefPart = { part_type: 'tool_result'; data: ToolResult }\nexport type ImagePart = { part_type: 'image'; data: FileType }\nexport type DataPart = { part_type: 'data'; data: object }\nexport type DistriPart = TextPart | ToolCallPart | ToolResultRefPart | ImagePart | DataPart;\n\n/**\n * Union type for parts that can appear in ToolResult (frontend or backend format)\n */\nexport type ToolResultPart = DistriPart;\n\n\n\n/**\n * File type for images\n */\nexport interface FileBytes {\n  mime_type: string;\n  data: string; // Base64 encoded data\n  name?: string;\n}\n\nexport interface FileUrl {\n  mime_type: string;\n  url: string; // File Url\n  name?: string;\n}\nexport type FileType = FileBytes | FileUrl;\n\n/**\n * Tool definition interface following AG-UI pattern\n */\nexport interface DistriBaseTool {\n  name: string;\n  type: 'function' | 'ui';\n  description: string;\n  parameters: object; // JSON Schema\n  is_final?: boolean;\n  autoExecute?: boolean;\n  isExternal?: boolean; // True if frontend handles execution, false if backend handles it\n}\n\nexport interface DistriFnTool extends DistriBaseTool {\n  type: 'function';\n  handler: ToolHandler;\n  onToolComplete?: (toolCallId: string, toolResult: ToolResult) => void;\n}\n\n/**\n * Tool handler function\n */\nexport interface ToolHandler {\n  (input: any): Promise<string | number | boolean | null | object>;\n}\n\n\n/**\n * Tool call from agent\n */\nexport interface ToolCall {\n  tool_call_id: string;\n  tool_name: string;\n  input: any; // Parsed JSON input\n}\n\n/**\n * Tool result structure that can come from backend or frontend\n */\nexport interface ToolResult {\n  readonly tool_call_id: string;\n  readonly tool_name: string;\n  readonly parts: readonly ToolResultPart[];\n}\n\n/**\n * Tool result data that goes inside the parts array\n */\nexport interface ToolResultData {\n  result: string | number | boolean | null | object;\n  success: boolean;\n  error?: string;\n}\n\n/**\n * Type-safe helper to create a successful ToolResult\n * Uses proper DistriPart structure - conversion to backend format happens in encoder\n */\nexport function createSuccessfulToolResult(\n  toolCallId: string,\n  toolName: string,\n  result: string | number | boolean | null | object\n): ToolResult {\n  return {\n    tool_call_id: toolCallId,\n    tool_name: toolName,\n    parts: [{\n      part_type: 'data' as const,\n      data: {\n        result,\n        success: true,\n        error: undefined\n      } satisfies ToolResultData\n    }]\n  };\n}\n\n/**\n * Type-safe helper to create a failed ToolResult\n * Uses proper DistriPart structure - conversion to backend format happens in encoder\n */\nexport function createFailedToolResult(\n  toolCallId: string,\n  toolName: string,\n  error: string,\n  result?: string | number | boolean | null | object\n): ToolResult {\n  return {\n    tool_call_id: toolCallId,\n    tool_name: toolName,\n    parts: [{\n      part_type: 'data' as const,\n      data: {\n        result: result ?? `Tool execution failed: ${error}`,\n        success: false,\n        error\n      } satisfies ToolResultData\n    }]\n  };\n}\n\n/**\n * Type guard to check if an object is a frontend DistriPart with data\n */\nfunction isDataPart(part: unknown): part is DataPart {\n  return (\n    typeof part === 'object' &&\n    part !== null &&\n    'part_type' in part &&\n    part.part_type === 'data' &&\n    'data' in part\n  );\n}\n/**\n * Type guard to check if data has ToolResultData structure\n */\nfunction isToolResultData(data: unknown): data is ToolResultData {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'success' in data &&\n    typeof (data as ToolResultData).success === 'boolean'\n  );\n}\n\n/**\n * Type-safe helper to extract ToolResultData from a ToolResult\n * Handles both frontend DistriPart format and backend BackendPart format\n */\nexport function extractToolResultData(toolResult: ToolResult): ToolResultData | null {\n  if (!toolResult.parts || !Array.isArray(toolResult.parts) || toolResult.parts.length === 0) {\n    return null;\n  }\n\n  const firstPart = toolResult.parts[0];\n\n  // Handle frontend DistriPart structure (type field)\n  if (isDataPart(firstPart)) {\n    const data = firstPart.data;\n\n    // If data is already ToolResultData structure\n    if (isToolResultData(data)) {\n      return {\n        result: data.result,\n        success: data.success,\n        error: data.error\n      };\n    }\n\n    // If data is a string, try to parse as JSON\n    if (typeof data === 'string') {\n      try {\n        const parsed = JSON.parse(data);\n        if (isToolResultData(parsed)) {\n          return {\n            result: parsed.result,\n            success: parsed.success,\n            error: parsed.error\n          };\n        }\n        // If parsed but not ToolResultData structure, treat as successful result\n        return {\n          result: parsed,\n          success: true,\n          error: undefined\n        };\n      } catch {\n        // JSON parsing failed, treat string as successful result\n        return {\n          result: data,\n          success: true,\n          error: undefined\n        };\n      }\n    }\n\n    // For other data types, assume successful result\n    return {\n      result: data,\n      success: true,\n      error: undefined\n    };\n  }\n\n  return null;\n}\n\n\n/**\n * Distri-specific Agent type that wraps A2A AgentCard\n */\nexport interface AgentDefinition {\n  /** The name of the agent. */\n  name: string;\n\n  id: string;\n\n  /** A brief description of the agent's purpose. */\n  description?: string;\n\n  /** The version of the agent. */\n  version?: string;\n\n  /** The system prompt for the agent, if any. */\n  system_prompt?: string | null;\n\n  /** A list of MCP server definitions associated with the agent. */\n  mcp_servers?: McpDefinition[];\n\n  /** Settings related to the model used by the agent. */\n  model_settings?: ModelSettings;\n\n  /** The size of the history to maintain for the agent. */\n  history_size?: number;\n\n  /** The planning configuration for the agent, if any. */\n  plan?: any;\n\n  /** A2A-specific fields */\n  icon_url?: string;\n\n  max_iterations?: number;\n\n  skills?: AgentSkill[];\n\n  /** List of sub-agents that this agent can transfer control to */\n  sub_agents?: string[];\n\n\n  agentType?: string;\n\n  tools?: DistriBaseTool[];\n\n}\n\n\nexport interface McpDefinition {\n  /** The filter applied to the tools in this MCP definition. */\n  filter?: string[];\n\n  /** The name of the MCP server. */\n  name: string;\n\n  /** The type of the MCP server (Tool or Agent). */\n  type?: McpServerType; // Use 'type' here instead of 'r#type'\n}\n\nexport interface ModelSettings {\n  model: string;\n  temperature: number;\n  max_tokens: number;\n  top_p: number;\n  frequency_penalty: number;\n  presence_penalty: number;\n  max_iterations: number;\n  provider: ModelProvider;\n  /** Additional parameters for the agent, if any. */\n  parameters?: any;\n\n  /** The format of the response, if specified. */\n  response_format?: any;\n}\n\nexport type McpServerType = 'tool' | 'agent';\n\nexport type ModelProvider = 'openai' | 'aigateway';\n\n/**\n * Distri Thread type for conversation management\n */\nexport interface DistriThread {\n  id: string;\n  title: string;\n  agent_id: string;\n  agent_name: string;\n  updated_at: string;\n  message_count: number;\n  last_message?: string;\n}\n\nexport interface Thread {\n  id: string;\n  title: string;\n  agent_id: string;\n  agent_name: string;\n  updated_at: string;\n  message_count: number;\n  last_message?: string;\n}\n\nexport interface ChatProps {\n  thread: Thread;\n  agent: AgentDefinition;\n  onThreadUpdate?: () => void;\n}\n\nexport interface SpeechToTextConfig {\n  model?: 'whisper-1';\n  language?: string;\n  temperature?: number;\n}\n\nexport interface StreamingTranscriptionOptions {\n  onTranscript?: (text: string, isFinal: boolean) => void;\n  onError?: (error: Error) => void;\n  onStart?: () => void;\n  onEnd?: () => void;\n}\n\n/**\n * Connection Status\n */\nexport type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';\n\n/**\n * Distri Client Configuration\n */\nexport interface DistriClientConfig {\n  baseUrl: string;\n  apiVersion?: string;\n  timeout?: number;\n  retryAttempts?: number;\n  retryDelay?: number;\n  debug?: boolean;\n  headers?: Record<string, string>;\n  interceptor?: (init?: RequestInit) => Promise<RequestInit | undefined>;\n}\n\n/**\n * Error Types\n */\nexport class DistriError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'DistriError';\n  }\n}\n\nexport class A2AProtocolError extends DistriError {\n  constructor(message: string, details?: any) {\n    super(message, 'A2A_PROTOCOL_ERROR', details);\n    this.name = 'A2AProtocolError';\n  }\n}\n\nexport class ApiError extends DistriError {\n  constructor(message: string, public statusCode: number, details?: any) {\n    super(message, 'API_ERROR', details);\n    this.name = 'ApiError';\n  }\n}\n\nexport class ConnectionError extends DistriError {\n  constructor(message: string, details?: any) {\n    super(message, 'CONNECTION_ERROR', details);\n    this.name = 'ConnectionError';\n  }\n}\n\n// Re-export A2A types for convenience\nexport type { AgentCard, Message, Task, TaskStatus, MessageSendParams, TaskStatusUpdateEvent, TaskArtifactUpdateEvent } from '@a2a-js/sdk/client';\n\nexport type A2AStreamEventData = Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent | Task;\n\n\nexport function isDistriMessage(event: DistriStreamEvent): event is DistriMessage {\n  return 'id' in event && 'role' in event && 'parts' in event;\n}\n\nexport function isDistriEvent(event: DistriStreamEvent): event is DistriEvent {\n  return 'type' in event && 'data' in event;\n}\n\nexport type DistriChatMessage = DistriEvent | DistriMessage;","// src/client/client.ts\nvar A2AClient = class {\n  agentBaseUrl;\n  agentCardPromise;\n  requestIdCounter = 1;\n  serviceEndpointUrl;\n  // To be populated from AgentCard after fetching\n  fetchFn;\n  /**\n   * Constructs an A2AClient instance.\n   * It initiates fetching the agent card from the provided agent baseUrl.\n   * The Agent Card is expected at `${agentBaseUrl}/.well-known/agent.json`.\n   * The `url` field from the Agent Card will be used as the RPC service endpoint.\n   * @param agentBaseUrl The base URL of the A2A agent (e.g., https://agent.example.com).\n   */\n  constructor(agentBaseUrl, fetchFn) {\n    this.agentBaseUrl = agentBaseUrl.replace(/\\/$/, \"\");\n    this.fetchFn = fetchFn || globalThis.fetch;\n    this.agentCardPromise = this._fetchAndCacheAgentCard();\n  }\n  /**\n   * Fetches the Agent Card from the agent's well-known URI and caches its service endpoint URL.\n   * This method is called by the constructor.\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async _fetchAndCacheAgentCard() {\n    const agentCardUrl = `${this.agentBaseUrl}/.well-known/agent.json`;\n    try {\n      const response = await this.fetchFn(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      const agentCard = await response.json();\n      if (!agentCard.url) {\n        throw new Error(\"Fetched Agent Card does not contain a valid 'url' for the service endpoint.\");\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      return agentCard;\n    } catch (error) {\n      console.error(\"Error fetching or parsing Agent Card:\");\n      throw error;\n    }\n  }\n  /**\n   * Retrieves the Agent Card.\n   * If an `agentBaseUrl` is provided, it fetches the card from that specific URL.\n   * Otherwise, it returns the card fetched and cached during client construction.\n   * @param agentBaseUrl Optional. The base URL of the agent to fetch the card from.\n   * If provided, this will fetch a new card, not use the cached one from the constructor's URL.\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async getAgentCard(agentBaseUrl) {\n    if (agentBaseUrl) {\n      const specificAgentBaseUrl = agentBaseUrl.replace(/\\/$/, \"\");\n      const agentCardUrl = `${specificAgentBaseUrl}/.well-known/agent.json`;\n      const response = await this.fetchFn(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      return await response.json();\n    }\n    return this.agentCardPromise;\n  }\n  /**\n   * Gets the RPC service endpoint URL. Ensures the agent card has been fetched first.\n   * @returns A Promise that resolves to the service endpoint URL string.\n   */\n  async _getServiceEndpoint() {\n    if (this.serviceEndpointUrl) {\n      return this.serviceEndpointUrl;\n    }\n    await this.agentCardPromise;\n    if (!this.serviceEndpointUrl) {\n      throw new Error(\"Agent Card URL for RPC endpoint is not available. Fetching might have failed.\");\n    }\n    return this.serviceEndpointUrl;\n  }\n  /**\n   * Helper method to make a generic JSON-RPC POST request.\n   * @param method The RPC method name.\n   * @param params The parameters for the RPC method.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async _postRpcRequest(method, params) {\n    const endpoint = await this._getServiceEndpoint();\n    const requestId = this.requestIdCounter++;\n    const rpcRequest = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      // Cast because TParams structure varies per method\n      id: requestId\n    };\n    const httpResponse = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n        // Expect JSON response for non-streaming requests\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!httpResponse.ok) {\n      let errorBodyText = \"(empty or non-JSON response)\";\n      try {\n        errorBodyText = await httpResponse.text();\n        const errorJson = JSON.parse(errorBodyText);\n        if (!errorJson.jsonrpc && errorJson.error) {\n          throw new Error(`RPC error for ${method}: ${errorJson.error.message} (Code: ${errorJson.error.code}, HTTP Status: ${httpResponse.status}) Data: ${JSON.stringify(errorJson.error.data)}`);\n        } else if (!errorJson.jsonrpc) {\n          throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"RPC error for\") || e.message.startsWith(\"HTTP error for\")) throw e;\n        throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n      }\n    }\n    const rpcResponse = await httpResponse.json();\n    if (rpcResponse.id !== requestId) {\n      console.error(`CRITICAL: RPC response ID mismatch for method ${method}. Expected ${requestId}, got ${rpcResponse.id}. This may lead to incorrect response handling.`);\n    }\n    return rpcResponse;\n  }\n  /**\n   * Sends a message to the agent.\n   * The behavior (blocking/non-blocking) and push notification configuration\n   * are specified within the `params.configuration` object.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * @param params The parameters for sending the message, including the message content and configuration.\n   * @returns A Promise resolving to SendMessageResponse, which can be a Message, Task, or an error.\n   */\n  async sendMessage(params) {\n    return this._postRpcRequest(\"message/send\", params);\n  }\n  /**\n   * Sends a message to the agent and streams back responses using Server-Sent Events (SSE).\n   * Push notification configuration can be specified in `params.configuration`.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params The parameters for sending the message.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   * The generator throws an error if streaming is not supported or if an HTTP/SSE error occurs.\n   */\n  async *sendMessageStream(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (AgentCard.capabilities.streaming is not true).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // This is the initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"message/stream\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n        // Crucial for SSE\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Sets or updates the push notification configuration for a given task.\n   * Requires the agent to support push notifications (`capabilities.pushNotifications: true` in AgentCard).\n   * @param params Parameters containing the taskId and the TaskPushNotificationConfig.\n   * @returns A Promise resolving to SetTaskPushNotificationConfigResponse.\n   */\n  async setTaskPushNotificationConfig(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.pushNotifications) {\n      throw new Error(\"Agent does not support push notifications (AgentCard.capabilities.pushNotifications is not true).\");\n    }\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/set\",\n      params\n    );\n  }\n  /**\n   * Gets the push notification configuration for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to GetTaskPushNotificationConfigResponse.\n   */\n  async getTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/get\",\n      params\n    );\n  }\n  /**\n   * Retrieves a task by its ID.\n   * @param params Parameters containing the taskId and optional historyLength.\n   * @returns A Promise resolving to GetTaskResponse, which contains the Task object or an error.\n   */\n  async getTask(params) {\n    return this._postRpcRequest(\"tasks/get\", params);\n  }\n  /**\n   * Cancels a task by its ID.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to CancelTaskResponse, which contains the updated Task object or an error.\n   */\n  async cancelTask(params) {\n    return this._postRpcRequest(\"tasks/cancel\", params);\n  }\n  /**\n   * Resubscribes to a task's event stream using Server-Sent Events (SSE).\n   * This is used if a previous SSE connection for an active task was broken.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params Parameters containing the taskId.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   */\n  async *resubscribeTask(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (required for tasks/resubscribe).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // Initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"tasks/resubscribe\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream on resubscribe. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Parses an HTTP response body as an A2A Server-Sent Event stream.\n   * Each 'data' field of an SSE event is expected to be a JSON-RPC 2.0 Response object,\n   * specifically a SendStreamingMessageResponse (or similar structure for resubscribe).\n   * @param response The HTTP Response object whose body is the SSE stream.\n   * @param originalRequestId The ID of the client's JSON-RPC request that initiated this stream.\n   * Used to validate the `id` in the streamed JSON-RPC responses.\n   * @returns An AsyncGenerator yielding the `result` field of each valid JSON-RPC success response from the stream.\n   */\n  async *_parseA2ASseStream(response, originalRequestId) {\n    if (!response.body) {\n      throw new Error(\"SSE response body is undefined. Cannot read stream.\");\n    }\n    const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();\n    let buffer = \"\";\n    let eventDataBuffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          if (eventDataBuffer.trim()) {\n            const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n            yield result;\n          }\n          break;\n        }\n        buffer += value;\n        let lineEndIndex;\n        while ((lineEndIndex = buffer.indexOf(\"\\n\")) >= 0) {\n          const line = buffer.substring(0, lineEndIndex).trim();\n          buffer = buffer.substring(lineEndIndex + 1);\n          if (line === \"\") {\n            if (eventDataBuffer) {\n              const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n              yield result;\n              eventDataBuffer = \"\";\n            }\n          } else if (line.startsWith(\"data:\")) {\n            eventDataBuffer += line.substring(5).trimStart() + \"\\n\";\n          } else if (line.startsWith(\":\")) {\n          } else if (line.includes(\":\")) {\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error reading or parsing SSE stream:\", error.message);\n      throw error;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  /**\n   * Processes a single SSE event's data string, expecting it to be a JSON-RPC response.\n   * @param jsonData The string content from one or more 'data:' lines of an SSE event.\n   * @param originalRequestId The ID of the client's request that initiated the stream.\n   * @returns The `result` field of the parsed JSON-RPC success response.\n   * @throws Error if data is not valid JSON, not a valid JSON-RPC response, an error response, or ID mismatch.\n   */\n  _processSseEventData(jsonData, originalRequestId) {\n    if (!jsonData.trim()) {\n      throw new Error(\"Attempted to process empty SSE event data.\");\n    }\n    try {\n      const sseJsonRpcResponse = JSON.parse(jsonData.replace(/\\n$/, \"\"));\n      const a2aStreamResponse = sseJsonRpcResponse;\n      if (a2aStreamResponse.id !== originalRequestId) {\n        console.warn(`SSE Event's JSON-RPC response ID mismatch. Client request ID: ${originalRequestId}, event response ID: ${a2aStreamResponse.id}.`);\n      }\n      if (this.isErrorResponse(a2aStreamResponse)) {\n        const err = a2aStreamResponse.error;\n        throw new Error(`SSE event contained an error: ${err.message} (Code: ${err.code}) Data: ${JSON.stringify(err.data)}`);\n      }\n      if (!(\"result\" in a2aStreamResponse) || typeof a2aStreamResponse.result === \"undefined\") {\n        throw new Error(`SSE event JSON-RPC response is missing 'result' field. Data: ${jsonData}`);\n      }\n      const successResponse = a2aStreamResponse;\n      return successResponse.result;\n    } catch (e) {\n      if (e.message.startsWith(\"SSE event contained an error\") || e.message.startsWith(\"SSE event JSON-RPC response is missing 'result' field\")) {\n        throw e;\n      }\n      console.error(\"Failed to parse SSE event data string or unexpected JSON-RPC structure:\", jsonData, e);\n      throw new Error(`Failed to parse SSE event data: \"${jsonData.substring(0, 100)}...\". Original error: ${e.message}`);\n    }\n  }\n  isErrorResponse(response) {\n    return \"error\" in response;\n  }\n};\n\nexport {\n  A2AClient\n};\n","import { Message, Part } from '@a2a-js/sdk/client';\nimport { DistriMessage, DistriPart, MessageRole, InvokeContext, ToolCall, ToolResult, FileUrl, FileBytes, DistriChatMessage } from './types';\nimport { DistriEvent, RunStartedEvent, RunFinishedEvent, PlanStartedEvent, PlanFinishedEvent, ToolExecutionStartEvent, ToolExecutionEndEvent, TextMessageStartEvent, TextMessageContentEvent, TextMessageEndEvent, ToolCallsEvent, ToolResultsEvent, RunErrorEvent } from './events';\nimport { FileWithBytes, FileWithUri } from '@a2a-js/sdk';\n\n/**\n * Converts an A2A Message to a DistriMessage\n */\nexport function convertA2AMessageToDistri(a2aMessage: Message): DistriMessage {\n  // Map A2A roles to Distri roles (A2A only supports 'agent' and 'user')\n  const role: MessageRole = a2aMessage.role === 'agent' ? 'assistant' : 'user';\n\n  return {\n    id: a2aMessage.messageId,\n    role,\n    parts: a2aMessage.parts.map(convertA2APartToDistri),\n    created_at: (a2aMessage as any).createdAt,\n  };\n}\n\n/**\n * Converts A2A status-update events to DistriEvent based on metadata type\n */\nexport function convertA2AStatusUpdateToDistri(statusUpdate: any): DistriEvent | null {\n  if (!statusUpdate.metadata || !statusUpdate.metadata.type) {\n    return null;\n  }\n\n  const metadata = statusUpdate.metadata;\n\n  switch (metadata.type) {\n    case 'run_started': {\n      const runStartedResult: RunStartedEvent = {\n        type: 'run_started',\n        data: {\n          runId: statusUpdate.runId,\n          taskId: statusUpdate.taskId\n        }\n      };\n      return runStartedResult;\n    }\n\n    case 'run_error': {\n      const runErrorResult: RunErrorEvent = {\n        type: 'run_error',\n        data: {\n          message: statusUpdate.error,\n          code: statusUpdate.code\n        }\n      };\n      return runErrorResult;\n    }\n\n    case 'run_finished': {\n      const runFinishedResult: RunFinishedEvent = {\n        type: 'run_finished',\n        data: {\n          runId: statusUpdate.runId,\n          taskId: statusUpdate.taskId\n        }\n      };\n      return runFinishedResult;\n    }\n\n    case 'plan_started': {\n      const planStartedResult: PlanStartedEvent = {\n        type: 'plan_started',\n        data: {\n          initial_plan: metadata.initial_plan\n        }\n      };\n      return planStartedResult;\n    }\n\n    case 'plan_finished': {\n      const planFinishedResult: PlanFinishedEvent = {\n        type: 'plan_finished',\n        data: {\n          total_steps: metadata.total_steps\n        }\n      };\n      return planFinishedResult;\n    }\n\n    case 'step_started': {\n      const stepStartedResult: any = {\n        type: 'step_started',\n        data: {\n          step_id: metadata.step_id,\n          step_title: metadata.step_title || 'Processing',\n          step_index: metadata.step_index || 0\n        }\n      };\n      return stepStartedResult;\n    }\n\n    case 'step_completed': {\n      const stepCompletedResult: any = {\n        type: 'step_completed',\n        data: {\n          step_id: metadata.step_id,\n          step_title: metadata.step_title || 'Processing',\n          step_index: metadata.step_index || 0\n        }\n      };\n      return stepCompletedResult;\n    }\n\n    case 'tool_execution_start': {\n      const toolStartResult: ToolExecutionStartEvent = {\n        type: 'tool_execution_start',\n        data: {\n          tool_call_id: metadata.tool_call_id,\n          tool_call_name: metadata.tool_call_name || 'Tool',\n          parent_message_id: statusUpdate.taskId\n        }\n      };\n      return toolStartResult;\n    }\n\n    case 'tool_execution_end': {\n      const toolEndResult: ToolExecutionEndEvent = {\n        type: 'tool_execution_end',\n        data: {\n          tool_call_id: metadata.tool_call_id\n        }\n      };\n      return toolEndResult;\n    }\n\n    case 'text_message_start': {\n      const textStartResult: TextMessageStartEvent = {\n        type: 'text_message_start',\n        data: {\n          message_id: metadata.message_id,\n          step_id: metadata.step_id || '',\n          role: metadata.role === 'assistant' ? 'assistant' : 'user'\n        }\n      };\n      return textStartResult;\n    }\n\n    case 'text_message_content': {\n      const textContentResult: TextMessageContentEvent = {\n        type: 'text_message_content',\n        data: {\n          message_id: metadata.message_id,\n          step_id: metadata.step_id || '',\n          delta: metadata.delta || ''\n        }\n      };\n      return textContentResult;\n    }\n\n    case 'text_message_end': {\n      const textEndResult: TextMessageEndEvent = {\n        type: 'text_message_end',\n        data: {\n          message_id: metadata.message_id,\n          step_id: metadata.step_id || ''\n        }\n      };\n      return textEndResult;\n    }\n\n    case 'tool_calls': {\n      const toolCallsResult: ToolCallsEvent = {\n        type: 'tool_calls',\n        data: {\n          tool_calls: metadata.tool_calls || []\n        }\n      };\n      return toolCallsResult;\n    }\n\n    case 'tool_results': {\n      const toolResultsResult: ToolResultsEvent = {\n        type: 'tool_results',\n        data: {\n          results: metadata.results || []\n        }\n      };\n      return toolResultsResult;\n    }\n\n    default: {\n      // For unrecognized metadata types, create a generic run_started event\n      console.warn(`Unhandled status update metadata type: ${metadata.type}`, metadata);\n      const defaultResult: RunStartedEvent = {\n        type: 'run_started',\n        data: {\n          runId: statusUpdate.runId,\n          taskId: statusUpdate.taskId\n        }\n      };\n      return defaultResult;\n    }\n  }\n}\n\n/**\n * Enhanced decoder for A2A stream events that properly handles all event types\n */\nexport function decodeA2AStreamEvent(event: any): DistriChatMessage | null {\n\n  // Handle regular messages\n  if (event.kind === 'message') {\n    return convertA2AMessageToDistri(event as Message);\n  }\n\n  // Handle status updates with proper conversion\n  if (event.kind === 'status-update') {\n    return convertA2AStatusUpdateToDistri(event);\n  }\n\n\n\n  return null;\n}\n\n/**\n * Process A2A stream data (like from stream.json) and convert to DistriMessage/DistriEvent/DistriArtifact array\n */\nexport function processA2AStreamData(streamData: any[]): (DistriMessage | DistriEvent)[] {\n  const results: (DistriMessage | DistriEvent)[] = [];\n\n  for (const item of streamData) {\n    const converted = decodeA2AStreamEvent(item);\n    if (converted) {\n      results.push(converted);\n    }\n  }\n\n  return results;\n}\n\n/**\n * Process A2A messages.json data and convert to DistriMessage array\n */\nexport function processA2AMessagesData(data: any[]): DistriMessage[] {\n  const results: DistriMessage[] = [];\n\n  for (const item of data) {\n    if (item.kind === 'message') {\n      // Regular message\n      const distriMessage = convertA2AMessageToDistri(item);\n      results.push(distriMessage);\n    }\n  }\n\n  return results;\n}\n\n/**\n * Converts an A2A Part to a DistriPart\n */\nexport function convertA2APartToDistri(a2aPart: Part): DistriPart {\n\n  switch (a2aPart.kind) {\n    case 'text':\n      return { part_type: 'text', data: a2aPart.text };\n    case 'file':\n      if ('uri' in a2aPart.file) {\n        const fileUrl: FileUrl = { mime_type: a2aPart.file.mimeType || 'application/octet-stream', url: a2aPart.file.uri || '' };\n        return { part_type: 'image', data: fileUrl };\n      }\n      else {\n        const fileBytes: FileBytes = { mime_type: a2aPart.file.mimeType || 'application/octet-stream', data: a2aPart.file.bytes || '' };\n        return { part_type: 'image', data: fileBytes };\n      }\n    case 'data':\n      switch (a2aPart.data.part_type) {\n        case 'tool_call':\n          return { part_type: 'tool_call', data: a2aPart.data as unknown as ToolCall };\n        case 'tool_result':\n          return { part_type: 'tool_result', data: a2aPart.data as unknown as ToolResult };\n        default:\n          return { part_type: 'data', data: a2aPart.data };\n      }\n    default:\n      // For unknown parts, convert to text by stringifying\n      return { part_type: 'text', data: JSON.stringify(a2aPart) };\n  }\n}\n\n/**\n * Converts a DistriMessage to an A2A Message using the provided context\n */\nexport function convertDistriMessageToA2A(distriMessage: DistriMessage, context: InvokeContext): Message {\n  // Map Distri roles to A2A roles (A2A only supports 'agent' and 'user')\n  let role: 'agent' | 'user';\n  switch (distriMessage.role) {\n    case 'assistant':\n      role = 'agent';\n      break;\n    case 'user':\n      role = 'user';\n      break;\n    case 'system':\n    case 'tool':\n      // A2A doesn't support these roles, map to user as fallback\n      role = 'user';\n      break;\n    default:\n      role = 'user';\n  }\n\n  return {\n    messageId: distriMessage.id,\n    role,\n    parts: distriMessage.parts.map(convertDistriPartToA2A),\n    kind: 'message',\n    contextId: context.thread_id,\n    taskId: context.task_id || context.run_id || undefined,\n  };\n}\n\n/**\n * Converts a DistriPart to an A2A Part\n */\nexport function convertDistriPartToA2A(distriPart: DistriPart): Part {\n  let result: Part;\n\n  switch (distriPart.part_type) {\n    case 'text':\n      result = { kind: 'text', text: distriPart.data };\n      break;\n    case 'image':\n      if ('url' in distriPart.data) {\n        const fileUri: FileWithUri = { mimeType: distriPart.data.mime_type, uri: distriPart.data.url };\n        result = { kind: 'file', file: fileUri };\n      } else {\n        const fileBytes: FileWithBytes = { mimeType: distriPart.data.mime_type, bytes: distriPart.data.data };\n        result = { kind: 'file', file: fileBytes };\n      }\n      break;\n    case 'tool_call':\n      result = {\n        kind: 'data',\n        data: {\n          part_type: 'tool_call',\n          data: distriPart.data\n        }\n      };\n      break;\n    case 'tool_result': {\n      // Convert ToolResult to proper ToolResponse structure with parts\n      const toolResult = distriPart.data as ToolResult;\n\n      // Convert ToolResult parts to proper Part format\n      const parts = toolResult.parts.map(part => {\n        if ('type' in part && part.type === 'data') {\n          // Convert DistriPart data to Part::Data format\n          return {\n            part_type: 'data',\n            data: part.data\n          };\n        } else if ('part_type' in part) {\n          // Already in correct format\n          return part;\n        } else {\n          // Fallback - wrap as data part\n          return {\n            part_type: 'data',\n            data: part\n          };\n        }\n      });\n\n      result = {\n        kind: 'data',\n        data: {\n          part_type: 'tool_result',\n          data: {\n            tool_call_id: toolResult.tool_call_id,\n            tool_name: toolResult.tool_name,\n            parts: parts\n          }\n        }\n      };\n      break;\n    }\n    case 'data': {\n      // A2A DataPart expects data to be an object with string keys\n      // Convert null/primitive values to an object structure\n      const dataValue = distriPart.data;\n      if (dataValue === null || typeof dataValue !== 'object' || Array.isArray(dataValue)) {\n        result = { kind: 'data', data: { value: dataValue } };\n      } else {\n        const dataObj: { [k: string]: unknown } = dataValue as { [k: string]: unknown };\n        result = { kind: 'data', data: dataObj };\n      }\n      break;\n    }\n  }\n  return result;\n}\n\n/**\n * Extract text content from DistriMessage\n */\nexport function extractTextFromDistriMessage(message: DistriMessage): string {\n  return message.parts\n    .filter(part => part.part_type === 'text')\n    .map(part => (part as { part_type: 'text'; data: string }).data)\n    .join('\\n');\n}\n\n/**\n * Extract tool calls from DistriMessage\n */\nexport function extractToolCallsFromDistriMessage(message: DistriMessage): any[] {\n  return message.parts\n    .filter(part => part.part_type === 'tool_call')\n    .map(part => (part as { part_type: 'tool_call'; data: any }).data);\n}\n\n/**\n * Extract tool results from DistriMessage\n */\nexport function extractToolResultsFromDistriMessage(message: DistriMessage): any[] {\n  return message.parts\n    .filter(part => part.part_type === 'tool_result')\n    .map(part => (part as { part_type: 'tool_result'; data: any }).data);\n}","import { A2AClient, Message, MessageSendParams, Task, SendMessageResponse, GetTaskResponse, Part } from '@a2a-js/sdk/client';\nimport {\n  DistriMessage,\n  DistriPart,\n  AgentDefinition,\n  DistriThread,\n  InvokeContext,\n  DistriClientConfig,\n  DistriError,\n  ApiError,\n  A2AProtocolError,\n  A2AStreamEventData,\n  SpeechToTextConfig,\n  StreamingTranscriptionOptions,\n  ToolResult\n} from './types';\nimport { convertA2AMessageToDistri, convertDistriMessageToA2A } from './encoder';\n/**\n * Enhanced Distri Client that wraps A2AClient and adds Distri-specific features\n */\nexport class DistriClient {\n  private config: Required<DistriClientConfig>;\n  private agentClients = new Map<string, A2AClient>();\n\n  constructor(config: DistriClientConfig) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/$/, ''),\n      apiVersion: config.apiVersion || 'v1',\n      timeout: config.timeout || 30000,\n      retryAttempts: config.retryAttempts || 3,\n      retryDelay: config.retryDelay || 1000,\n      debug: config.debug || false,\n      headers: config.headers || {},\n      interceptor: config.interceptor || ((init?: RequestInit) => Promise.resolve(init))\n    };\n\n    this.debug('DistriClient initialized with config:', this.config);\n  }\n\n  /**\n   * Start streaming speech-to-text transcription via WebSocket\n   */\n  async streamingTranscription(options: StreamingTranscriptionOptions = {}) {\n    const baseUrl = this.config.baseUrl;\n    // Convert HTTP/HTTPS URLs to WebSocket URLs\n    const wsUrl = baseUrl.replace('http://', 'ws://').replace('https://', 'wss://') + '/voice/stream';\n\n    return new Promise<{\n      sendAudio: (audioData: ArrayBuffer) => void;\n      sendText: (text: string) => void;\n      stop: () => void;\n      close: () => void;\n    }>((resolve, reject) => {\n      const ws = new WebSocket(wsUrl);\n      let isResolved = false;\n\n      ws.onopen = () => {\n        // Start session\n        ws.send(JSON.stringify({ type: 'start_session' }));\n        options.onStart?.();\n\n        if (!isResolved) {\n          isResolved = true;\n          resolve({\n            sendAudio: (audioData: ArrayBuffer) => {\n              if (ws.readyState === WebSocket.OPEN) {\n                ws.send(audioData);\n              }\n            },\n            sendText: (text: string) => {\n              if (ws.readyState === WebSocket.OPEN) {\n                ws.send(JSON.stringify({ type: 'text_chunk', text }));\n              }\n            },\n            stop: () => {\n              if (ws.readyState === WebSocket.OPEN) {\n                ws.send(JSON.stringify({ type: 'end_session' }));\n              }\n            },\n            close: () => {\n              ws.close();\n            }\n          });\n        }\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n\n          switch (data.type) {\n            case 'text_chunk':\n              options.onTranscript?.(data.text || '', data.is_final || false);\n              break;\n            case 'session_started':\n              this.debug('Speech-to-text session started');\n              break;\n            case 'session_ended':\n              this.debug('Speech-to-text session ended');\n              options.onEnd?.();\n              break;\n            case 'error':\n              const error = new Error(data.message || 'WebSocket error');\n              this.debug('Speech-to-text error:', error);\n              options.onError?.(error);\n              break;\n            default:\n              this.debug('Unknown message type:', data.type);\n          }\n        } catch (error) {\n          const parseError = new Error('Failed to parse WebSocket message');\n          this.debug('Parse error:', parseError);\n          options.onError?.(parseError);\n        }\n      };\n\n      ws.onerror = (event) => {\n        const error = new Error('WebSocket connection error');\n        this.debug('WebSocket error:', event);\n        options.onError?.(error);\n\n        if (!isResolved) {\n          isResolved = true;\n          reject(error);\n        }\n      };\n\n      ws.onclose = (event) => {\n        this.debug('WebSocket closed:', event.code, event.reason);\n        options.onEnd?.();\n      };\n    });\n  }\n  /**\n   * Transcribe audio blob to text using speech-to-text API\n   */\n  async transcribe(audioBlob: Blob, config: SpeechToTextConfig = {}): Promise<string> {\n    try {\n      // Convert blob to base64\n      const arrayBuffer = await audioBlob.arrayBuffer();\n      const uint8Array = new Uint8Array(arrayBuffer);\n      const base64String = btoa(String.fromCharCode(...uint8Array));\n\n      const requestBody = {\n        audio: base64String,\n        model: config.model || 'whisper-1',\n        ...(config.language && { language: config.language }),\n        ...(config.temperature !== undefined && { temperature: config.temperature }),\n      };\n\n      this.debug('Transcribing audio:', {\n        model: requestBody.model,\n        language: config.language,\n        audioSize: audioBlob.size\n      });\n\n      const response = await this.fetch(`/tts/transcribe`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...this.config.headers,\n        },\n        body: JSON.stringify(requestBody),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        const errorMessage = errorData.error || `Transcription failed: ${response.status}`;\n        throw new ApiError(errorMessage, response.status);\n      }\n\n      const result = await response.json();\n      const transcription = result.text || '';\n\n      this.debug('Transcription result:', { text: transcription });\n      return transcription;\n\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError('Failed to transcribe audio', 'TRANSCRIPTION_ERROR', error);\n    }\n  }\n\n  /**\n   * Get all available agents from the Distri server\n   */\n  async getAgents(): Promise<AgentDefinition[]> {\n    try {\n      const response = await this.fetch(`/agents`, {\n        headers: {\n          ...this.config.headers,\n        }\n      });\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch agents: ${response.statusText}`, response.status);\n      }\n\n      const agents: AgentDefinition[] = await response.json();\n      // Temporary fix for agents without an id\n      agents.forEach(agent => {\n        if (!agent.id) {\n          agent.id = agent.name;\n        }\n      });\n\n      return agents;\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError('Failed to fetch agents', 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get specific agent by ID\n   */\n  async getAgent(agentId: string): Promise<AgentDefinition> {\n    try {\n      const response = await this.fetch(`/agents/${agentId}`, {\n        headers: {\n          ...this.config.headers,\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 404) {\n          throw new ApiError(`Agent not found: ${agentId}`, 404);\n        }\n        throw new ApiError(`Failed to fetch agent: ${response.statusText}`, response.status);\n      }\n\n      const agent: AgentDefinition = await response.json();\n      // If the agent doesn't have an id, set it to the agentId\n      if (!agent.id) {\n        agent.id = agentId;\n      }\n      return agent;\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch agent ${agentId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get or create A2AClient for an agent\n   */\n  private getA2AClient(agentId: string): A2AClient {\n    if (!this.agentClients.has(agentId)) {\n      // Use agent's URL from the configured baseUrl\n      const fetchFn = this.fetchAbsolute.bind(this);\n      const agentUrl = `${this.config.baseUrl}/agents/${agentId}`;\n      const client = new A2AClient(agentUrl, fetchFn);\n      this.agentClients.set(agentId, client);\n      this.debug(`Created A2AClient for agent ${agentId} at ${agentUrl}`);\n    }\n    return this.agentClients.get(agentId)!;\n  }\n\n  /**\n   * Send a message to an agent\n   */\n  async sendMessage(agentId: string, params: MessageSendParams): Promise<Message | Task> {\n    try {\n      const client = this.getA2AClient(agentId);\n\n      const response: SendMessageResponse = await client.sendMessage(params);\n\n      if ('error' in response && response.error) {\n        throw new A2AProtocolError(response.error.message, response.error);\n      }\n\n      if ('result' in response) {\n        const result = response.result;\n        this.debug(`Message sent to ${agentId}, got ${result.kind}:`, result);\n        return result;\n      }\n\n      throw new DistriError('Invalid response format', 'INVALID_RESPONSE');\n    } catch (error) {\n      if (error instanceof A2AProtocolError || error instanceof DistriError) throw error;\n      throw new DistriError(`Failed to send message to agent ${agentId}`, 'SEND_MESSAGE_ERROR', error);\n    }\n  }\n\n  /**\n   * Send a streaming message to an agent\n   */\n  async * sendMessageStream(agentId: string, params: MessageSendParams): AsyncGenerator<A2AStreamEventData> {\n    console.log('sendMessageStream', agentId, params);\n    try {\n      const client = this.getA2AClient(agentId);\n      yield* await client.sendMessageStream(params);\n    } catch (error) {\n      console.error(error);\n      throw new DistriError(`Failed to stream message to agent ${agentId}`, 'STREAM_MESSAGE_ERROR', error);\n\n    }\n  }\n\n  /**\n   * Get task details\n   */\n  async getTask(agentId: string, taskId: string): Promise<Task> {\n    try {\n      const client = this.getA2AClient(agentId);\n      const response: GetTaskResponse = await client.getTask({ id: taskId });\n\n      if ('error' in response && response.error) {\n        throw new A2AProtocolError(response.error.message, response.error);\n      }\n\n      if ('result' in response) {\n        const result = response.result;\n        this.debug(`Got task ${taskId} from ${agentId}:`, result);\n        return result;\n      }\n\n      throw new DistriError('Invalid response format', 'INVALID_RESPONSE');\n    } catch (error) {\n      if (error instanceof A2AProtocolError || error instanceof DistriError) throw error;\n      throw new DistriError(`Failed to get task ${taskId} from agent ${agentId}`, 'GET_TASK_ERROR', error);\n    }\n  }\n\n  /**\n   * Cancel a task\n   */\n  async cancelTask(agentId: string, taskId: string): Promise<void> {\n    try {\n      const client = this.getA2AClient(agentId);\n      await client.cancelTask({ id: taskId });\n      this.debug(`Cancelled task ${taskId} on agent ${agentId}`);\n    } catch (error) {\n      throw new DistriError(`Failed to cancel task ${taskId} on agent ${agentId}`, 'CANCEL_TASK_ERROR', error);\n    }\n  }\n\n  /**\n   * Get threads from Distri server\n   */\n  async getThreads(): Promise<DistriThread[]> {\n    try {\n      const response = await this.fetch(`/threads`);\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch threads: ${response.statusText}`, response.status);\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError('Failed to fetch threads', 'FETCH_ERROR', error);\n    }\n  }\n\n  async getThread(threadId: string): Promise<DistriThread> {\n    try {\n      const response = await this.fetch(`/threads/${threadId}`);\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch thread: ${response.statusText}`, response.status);\n      }\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch thread ${threadId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get thread messages\n   */\n  async getThreadMessages(threadId: string): Promise<Message[]> {\n    try {\n      const response = await this.fetch(`/threads/${threadId}/messages`);\n      if (!response.ok) {\n        if (response.status === 404) {\n          return []; // Thread not found, return empty messages\n        }\n        throw new ApiError(`Failed to fetch thread messages: ${response.statusText}`, response.status);\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch messages for thread ${threadId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get messages from a thread as DistriMessage format\n   */\n  async getThreadMessagesAsDistri(threadId: string): Promise<DistriMessage[]> {\n    const messages = await this.getThreadMessages(threadId);\n    return messages.map(convertA2AMessageToDistri);\n  }\n\n  /**\n   * Send a DistriMessage to a thread\n   */\n  async sendDistriMessage(threadId: string, message: DistriMessage, context: InvokeContext): Promise<void> {\n    const a2aMessage = convertDistriMessageToA2A(message, context);\n    const contextMetadata = context.getMetadata?.() || {};\n    const params: MessageSendParams = {\n      message: a2aMessage,\n      metadata: contextMetadata\n    };\n    await this.sendMessage(threadId, params);\n  }\n\n  /**\n   * Complete an external tool call\n   */\n  async completeTool(agentId: string, result: ToolResult): Promise<void> {\n    try {\n      const response = await this.fetch(`/agents/${agentId}/complete-tool`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...this.config.headers,\n        },\n        body: JSON.stringify({\n          tool_call_id: result.tool_call_id,\n          tool_response: result\n        })\n      });\n\n      if (!response.ok) {\n        throw new ApiError(`Failed to complete tool: ${response.statusText}`, response.status);\n      }\n\n      this.debug(`Tool completed: ${result.tool_name} (${result.tool_call_id}) for agent ${agentId}`);\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to complete tool ${result.tool_name} (${result.tool_call_id}) for agent ${agentId}`, 'COMPLETE_TOOL_ERROR', error);\n    }\n  }\n\n  /**\n   * Get the base URL for making direct requests\n   */\n  get baseUrl(): string {\n    return this.config.baseUrl;\n  }\n\n  /**\n   * Enhanced fetch with retry logic\n   */\n  private async fetchAbsolute(url: RequestInfo | URL, initialInit?: RequestInit): Promise<Response> {\n\n    const init = await this.config.interceptor(initialInit);\n    // Construct the full URL using baseUrl\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= this.config.retryAttempts; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n        const response = await fetch(url, {\n          ...init,\n          signal: controller.signal,\n          headers: {\n            ...this.config.headers,\n            ...init?.headers\n          }\n        });\n\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < this.config.retryAttempts) {\n          this.debug(`Request failed (attempt ${attempt + 1}), retrying in ${this.config.retryDelay}ms...`);\n          await this.delay(this.config.retryDelay);\n        }\n      }\n    }\n    throw lastError!;\n  }\n\n  /**\n   * Enhanced fetch with retry logic\n   */\n  private async fetch(input: RequestInfo | URL, initialInit?: RequestInit): Promise<Response> {\n    // Construct the full URL using baseUrl\n    const url = `${this.config.baseUrl}${input}`;\n    return this.fetchAbsolute(url, initialInit);\n  }\n\n  /**\n   * Delay utility\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Debug logging\n   */\n  private debug(...args: any[]): void {\n    if (this.config.debug) {\n      console.log('[DistriClient]', ...args);\n    }\n  }\n\n  /**\n   * Helper method to create A2A messages\n   */\n  static initMessage(\n\n    parts: Part[] | string,\n    role: 'agent' | 'user' = 'user',\n    message: Omit<Partial<Message>, 'parts' | 'role' | 'kind'>\n  ): Message {\n    return {\n      messageId: message.messageId || uuidv4(),\n      taskId: message.taskId || uuidv4(),\n      contextId: message.contextId,\n      role,\n      parts: Array.isArray(parts) ? parts : [{ kind: 'text', text: parts.trim() }],\n      ...message,\n      kind: 'message'\n    };\n  }\n\n  /**\n   * Create a DistriMessage instance\n   */\n  static initDistriMessage(\n    role: DistriMessage['role'],\n    parts: DistriPart[],\n    id?: string,\n    created_at?: string,\n  ): DistriMessage {\n    return {\n      id: id || uuidv4(),\n      role,\n      parts,\n      created_at,\n    };\n  }\n\n  /**\n   * Helper method to create message send parameters\n   */\n  static initMessageParams(\n    message: Message,\n    configuration?: MessageSendParams['configuration'],\n    metadata?: any\n  ): MessageSendParams {\n    return {\n      message,\n      configuration: {\n        acceptedOutputModes: ['text/plain'],\n        blocking: false, // Default to non-blocking for streaming\n        ...configuration\n      },\n      metadata\n    };\n  }\n\n  /**\n   * Create MessageSendParams from a DistriMessage using InvokeContext\n   */\n  static initDistriMessageParams(message: DistriMessage, context: InvokeContext): MessageSendParams {\n    const a2aMessage = convertDistriMessageToA2A(message, context);\n    const contextMetadata = context.getMetadata?.() || {};\n    return {\n      message: a2aMessage,\n      metadata: contextMetadata\n    };\n  }\n}\nexport function uuidv4(): string {\n  if (typeof crypto?.randomUUID === 'function') {\n    return crypto.randomUUID();\n  }\n  // Fallback for older browsers\n  const array = new Uint8Array(16);\n  crypto.getRandomValues(array);\n  // Per RFC4122 v4\n  array[6] = (array[6] & 0x0f) | 0x40;\n  array[8] = (array[8] & 0x3f) | 0x80;\n  return [...array].map((b, i) =>\n    ([4, 6, 8, 10].includes(i) ? '-' : '') + b.toString(16).padStart(2, '0')\n  ).join('');\n}","import { DistriClient } from './distri-client';\nimport {\n  AgentDefinition,\n  DistriBaseTool,\n  DistriChatMessage,\n  ToolResult,\n} from './types';\nimport { Message, MessageSendParams } from '@a2a-js/sdk/client';\nimport { decodeA2AStreamEvent } from './encoder';\n\n/**\n * Configuration for Agent invoke method\n */\nexport interface InvokeConfig {\n  /** Configuration for the message */\n  configuration?: MessageSendParams['configuration'];\n  /** Context/thread ID */\n  contextId?: string;\n  /** Metadata for the requests */\n  metadata?: any;\n}\n\n/**\n * Result from agent invoke\n */\nexport interface InvokeResult {\n  /** Final response message */\n  message?: Message;\n  /** Task if created */\n  task?: any;\n  /** Whether the response was streamed */\n  streamed: boolean;\n}\n\n/**\n * Enhanced Agent class with simple tool system following AG-UI pattern\n */\nexport class Agent {\n  private client: DistriClient;\n  private agentDefinition: AgentDefinition;\n\n  constructor(agentDefinition: AgentDefinition, client: DistriClient) {\n    this.agentDefinition = agentDefinition;\n    this.client = client;\n  }\n  /**\n   * Get agent information\n   */\n  get id(): string {\n    return this.agentDefinition.id;\n  }\n\n  get name(): string {\n    return this.agentDefinition.name;\n  }\n\n  get description(): string | undefined {\n    return this.agentDefinition.description;\n  }\n\n  get agentType(): string | undefined {\n    return this.agentDefinition.agentType;\n  }\n\n  get iconUrl(): string | undefined {\n    return this.agentDefinition.icon_url;\n  }\n\n  /**\n   * Get the full agent definition (including backend tools)\n   */\n  getDefinition(): AgentDefinition {\n    return this.agentDefinition;\n  }\n\n  /**\n   * Fetch messages for a thread (public method for useChat)\n   */\n  async getThreadMessages(threadId: string): Promise<Message[]> {\n    return this.client.getThreadMessages(threadId);\n  }\n\n  /**\n   * Direct (non-streaming) invoke\n   */\n  public async invoke(params: MessageSendParams, tools?: DistriBaseTool[]): Promise<Message> {\n    // Inject tool definitions into metadata\n    const enhancedParams = this.enhanceParamsWithTools(params, tools);\n    return await this.client.sendMessage(this.agentDefinition.id, enhancedParams) as Message;\n  }\n\n  /**\n   * Streaming invoke\n   */\n  public async invokeStream(params: MessageSendParams, tools?: DistriBaseTool[]): Promise<AsyncGenerator<DistriChatMessage>> {\n    // Inject tool definitions into metadata\n    const enhancedParams = this.enhanceParamsWithTools(params, tools);\n    const a2aStream = this.client.sendMessageStream(this.agentDefinition.id, enhancedParams);\n\n\n    return (async function* () {\n      const events = [];\n      const mappedEvents = [];\n      for await (const event of a2aStream) {\n        events.push(event);\n        const converted = decodeA2AStreamEvent(event);\n        mappedEvents.push(converted);\n        if (converted) {\n          yield converted;\n        }\n      }\n    })();\n  }\n\n  /**\n   * Enhance message params with tool definitions\n   */\n  private enhanceParamsWithTools(params: MessageSendParams, tools?: DistriBaseTool[]): MessageSendParams {\n    const metadata = {\n      ...params.metadata,\n      external_tools: tools?.map(tool => ({\n        name: tool.name,\n        description: tool.description,\n        parameters: tool.parameters,\n        is_final: tool.is_final\n      })) || []\n    };\n    return {\n      ...params,\n      metadata\n    };\n  }\n\n\n  /**\n   * Create an agent instance from an agent ID\n   */\n  static async create(agentIdOrDef: string | AgentDefinition, client: DistriClient): Promise<Agent> {\n    const agentDefinition = typeof agentIdOrDef === 'string' ? await client.getAgent(agentIdOrDef) : agentIdOrDef;\n    console.log(' Agent definition loaded:', {\n      id: agentDefinition.id,\n      name: agentDefinition.name,\n      tools: agentDefinition.tools?.map(t => ({\n        name: t.name,\n        type: t.type || 'function'\n      })) || [],\n      toolCount: agentDefinition.tools?.length || 0\n    });\n    return new Agent(agentDefinition, client);\n  }\n\n  /**\n   * Complete an external tool call by sending the result back to the server\n   */\n  async completeTool(result: ToolResult): Promise<void> {\n    await this.client.completeTool(this.agentDefinition.id, result);\n  }\n\n  /**\n   * List all available agents\n   */\n  static async list(client: DistriClient): Promise<Agent[]> {\n    const agentDefinitions = await client.getAgents();\n    return agentDefinitions.map(def => new Agent(def, client));\n  }\n}\n"],"mappings":"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","names":[]}