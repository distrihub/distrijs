{"version":3,"sources":["../../../node_modules/.pnpm/@a2a-js+sdk@https+++codeload.github.com+v3g42+a2a-js+tar.gz+51444c9/node_modules/@a2a-js/sdk/dist/chunk-CUGIRVQB.js","../src/types.ts","../src/distri-client.ts","../src/agent.ts"],"sourcesContent":["// src/client/client.ts\nvar A2AClient = class {\n  agentBaseUrl;\n  agentCardPromise;\n  requestIdCounter = 1;\n  serviceEndpointUrl;\n  // To be populated from AgentCard after fetching\n  fetchFn;\n  /**\n   * Constructs an A2AClient instance.\n   * It initiates fetching the agent card from the provided agent baseUrl.\n   * The Agent Card is expected at `${agentBaseUrl}/.well-known/agent.json`.\n   * The `url` field from the Agent Card will be used as the RPC service endpoint.\n   * @param agentBaseUrl The base URL of the A2A agent (e.g., https://agent.example.com).\n   */\n  constructor(agentBaseUrl, fetchFn) {\n    this.agentBaseUrl = agentBaseUrl.replace(/\\/$/, \"\");\n    this.fetchFn = fetchFn || globalThis.fetch;\n    this.agentCardPromise = this._fetchAndCacheAgentCard();\n  }\n  /**\n   * Fetches the Agent Card from the agent's well-known URI and caches its service endpoint URL.\n   * This method is called by the constructor.\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async _fetchAndCacheAgentCard() {\n    const agentCardUrl = `${this.agentBaseUrl}/.well-known/agent.json`;\n    try {\n      const response = await this.fetchFn(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      const agentCard = await response.json();\n      if (!agentCard.url) {\n        throw new Error(\"Fetched Agent Card does not contain a valid 'url' for the service endpoint.\");\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      return agentCard;\n    } catch (error) {\n      console.error(\"Error fetching or parsing Agent Card:\");\n      throw error;\n    }\n  }\n  /**\n   * Retrieves the Agent Card.\n   * If an `agentBaseUrl` is provided, it fetches the card from that specific URL.\n   * Otherwise, it returns the card fetched and cached during client construction.\n   * @param agentBaseUrl Optional. The base URL of the agent to fetch the card from.\n   * If provided, this will fetch a new card, not use the cached one from the constructor's URL.\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async getAgentCard(agentBaseUrl) {\n    if (agentBaseUrl) {\n      const specificAgentBaseUrl = agentBaseUrl.replace(/\\/$/, \"\");\n      const agentCardUrl = `${specificAgentBaseUrl}/.well-known/agent.json`;\n      const response = await this.fetchFn(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      return await response.json();\n    }\n    return this.agentCardPromise;\n  }\n  /**\n   * Gets the RPC service endpoint URL. Ensures the agent card has been fetched first.\n   * @returns A Promise that resolves to the service endpoint URL string.\n   */\n  async _getServiceEndpoint() {\n    if (this.serviceEndpointUrl) {\n      return this.serviceEndpointUrl;\n    }\n    await this.agentCardPromise;\n    if (!this.serviceEndpointUrl) {\n      throw new Error(\"Agent Card URL for RPC endpoint is not available. Fetching might have failed.\");\n    }\n    return this.serviceEndpointUrl;\n  }\n  /**\n   * Helper method to make a generic JSON-RPC POST request.\n   * @param method The RPC method name.\n   * @param params The parameters for the RPC method.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async _postRpcRequest(method, params) {\n    const endpoint = await this._getServiceEndpoint();\n    const requestId = this.requestIdCounter++;\n    const rpcRequest = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      // Cast because TParams structure varies per method\n      id: requestId\n    };\n    const httpResponse = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n        // Expect JSON response for non-streaming requests\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!httpResponse.ok) {\n      let errorBodyText = \"(empty or non-JSON response)\";\n      try {\n        errorBodyText = await httpResponse.text();\n        const errorJson = JSON.parse(errorBodyText);\n        if (!errorJson.jsonrpc && errorJson.error) {\n          throw new Error(`RPC error for ${method}: ${errorJson.error.message} (Code: ${errorJson.error.code}, HTTP Status: ${httpResponse.status}) Data: ${JSON.stringify(errorJson.error.data)}`);\n        } else if (!errorJson.jsonrpc) {\n          throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"RPC error for\") || e.message.startsWith(\"HTTP error for\")) throw e;\n        throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n      }\n    }\n    const rpcResponse = await httpResponse.json();\n    if (rpcResponse.id !== requestId) {\n      console.error(`CRITICAL: RPC response ID mismatch for method ${method}. Expected ${requestId}, got ${rpcResponse.id}. This may lead to incorrect response handling.`);\n    }\n    return rpcResponse;\n  }\n  /**\n   * Sends a message to the agent.\n   * The behavior (blocking/non-blocking) and push notification configuration\n   * are specified within the `params.configuration` object.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * @param params The parameters for sending the message, including the message content and configuration.\n   * @returns A Promise resolving to SendMessageResponse, which can be a Message, Task, or an error.\n   */\n  async sendMessage(params) {\n    return this._postRpcRequest(\"message/send\", params);\n  }\n  /**\n   * Sends a message to the agent and streams back responses using Server-Sent Events (SSE).\n   * Push notification configuration can be specified in `params.configuration`.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params The parameters for sending the message.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   * The generator throws an error if streaming is not supported or if an HTTP/SSE error occurs.\n   */\n  async *sendMessageStream(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (AgentCard.capabilities.streaming is not true).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // This is the initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"message/stream\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n        // Crucial for SSE\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Sets or updates the push notification configuration for a given task.\n   * Requires the agent to support push notifications (`capabilities.pushNotifications: true` in AgentCard).\n   * @param params Parameters containing the taskId and the TaskPushNotificationConfig.\n   * @returns A Promise resolving to SetTaskPushNotificationConfigResponse.\n   */\n  async setTaskPushNotificationConfig(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.pushNotifications) {\n      throw new Error(\"Agent does not support push notifications (AgentCard.capabilities.pushNotifications is not true).\");\n    }\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/set\",\n      params\n    );\n  }\n  /**\n   * Gets the push notification configuration for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to GetTaskPushNotificationConfigResponse.\n   */\n  async getTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/get\",\n      params\n    );\n  }\n  /**\n   * Retrieves a task by its ID.\n   * @param params Parameters containing the taskId and optional historyLength.\n   * @returns A Promise resolving to GetTaskResponse, which contains the Task object or an error.\n   */\n  async getTask(params) {\n    return this._postRpcRequest(\"tasks/get\", params);\n  }\n  /**\n   * Cancels a task by its ID.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to CancelTaskResponse, which contains the updated Task object or an error.\n   */\n  async cancelTask(params) {\n    return this._postRpcRequest(\"tasks/cancel\", params);\n  }\n  /**\n   * Resubscribes to a task's event stream using Server-Sent Events (SSE).\n   * This is used if a previous SSE connection for an active task was broken.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params Parameters containing the taskId.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   */\n  async *resubscribeTask(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (required for tasks/resubscribe).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // Initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"tasks/resubscribe\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream on resubscribe. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Parses an HTTP response body as an A2A Server-Sent Event stream.\n   * Each 'data' field of an SSE event is expected to be a JSON-RPC 2.0 Response object,\n   * specifically a SendStreamingMessageResponse (or similar structure for resubscribe).\n   * @param response The HTTP Response object whose body is the SSE stream.\n   * @param originalRequestId The ID of the client's JSON-RPC request that initiated this stream.\n   * Used to validate the `id` in the streamed JSON-RPC responses.\n   * @returns An AsyncGenerator yielding the `result` field of each valid JSON-RPC success response from the stream.\n   */\n  async *_parseA2ASseStream(response, originalRequestId) {\n    if (!response.body) {\n      throw new Error(\"SSE response body is undefined. Cannot read stream.\");\n    }\n    const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();\n    let buffer = \"\";\n    let eventDataBuffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          if (eventDataBuffer.trim()) {\n            const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n            yield result;\n          }\n          break;\n        }\n        buffer += value;\n        let lineEndIndex;\n        while ((lineEndIndex = buffer.indexOf(\"\\n\")) >= 0) {\n          const line = buffer.substring(0, lineEndIndex).trim();\n          buffer = buffer.substring(lineEndIndex + 1);\n          if (line === \"\") {\n            if (eventDataBuffer) {\n              const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n              yield result;\n              eventDataBuffer = \"\";\n            }\n          } else if (line.startsWith(\"data:\")) {\n            eventDataBuffer += line.substring(5).trimStart() + \"\\n\";\n          } else if (line.startsWith(\":\")) {\n          } else if (line.includes(\":\")) {\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error reading or parsing SSE stream:\", error.message);\n      throw error;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  /**\n   * Processes a single SSE event's data string, expecting it to be a JSON-RPC response.\n   * @param jsonData The string content from one or more 'data:' lines of an SSE event.\n   * @param originalRequestId The ID of the client's request that initiated the stream.\n   * @returns The `result` field of the parsed JSON-RPC success response.\n   * @throws Error if data is not valid JSON, not a valid JSON-RPC response, an error response, or ID mismatch.\n   */\n  _processSseEventData(jsonData, originalRequestId) {\n    if (!jsonData.trim()) {\n      throw new Error(\"Attempted to process empty SSE event data.\");\n    }\n    try {\n      const sseJsonRpcResponse = JSON.parse(jsonData.replace(/\\n$/, \"\"));\n      const a2aStreamResponse = sseJsonRpcResponse;\n      if (a2aStreamResponse.id !== originalRequestId) {\n        console.warn(`SSE Event's JSON-RPC response ID mismatch. Client request ID: ${originalRequestId}, event response ID: ${a2aStreamResponse.id}.`);\n      }\n      if (this.isErrorResponse(a2aStreamResponse)) {\n        const err = a2aStreamResponse.error;\n        throw new Error(`SSE event contained an error: ${err.message} (Code: ${err.code}) Data: ${JSON.stringify(err.data)}`);\n      }\n      if (!(\"result\" in a2aStreamResponse) || typeof a2aStreamResponse.result === \"undefined\") {\n        throw new Error(`SSE event JSON-RPC response is missing 'result' field. Data: ${jsonData}`);\n      }\n      const successResponse = a2aStreamResponse;\n      return successResponse.result;\n    } catch (e) {\n      if (e.message.startsWith(\"SSE event contained an error\") || e.message.startsWith(\"SSE event JSON-RPC response is missing 'result' field\")) {\n        throw e;\n      }\n      console.error(\"Failed to parse SSE event data string or unexpected JSON-RPC structure:\", jsonData, e);\n      throw new Error(`Failed to parse SSE event data: \"${jsonData.substring(0, 100)}...\". Original error: ${e.message}`);\n    }\n  }\n  isErrorResponse(response) {\n    return \"error\" in response;\n  }\n};\n\nexport {\n  A2AClient\n};\n","// Distri Framework Types - Based on A2A Protocol and SSE\nimport { AgentSkill, Message, Task, TaskArtifactUpdateEvent, TaskStatusUpdateEvent } from '@a2a-js/sdk/client';\n\n/**\n * Tool definition interface following AG-UI pattern\n */\nexport interface DistriTool {\n  name: string;\n  description: string;\n  parameters: any; // JSON Schema\n  handler: ToolHandler;\n}\n\n/**\n * Tool call from agent\n */\nexport interface ToolCall {\n  tool_call_id: string;\n  tool_name: string;\n  input: any; // Parsed JSON input\n}\n\n/**\n * Tool result for responding to tool calls\n */\nexport interface ToolResult {\n  tool_call_id: string;\n  result: any;\n  success: boolean;\n  error?: string;\n}\n\n/**\n * Tool handler function\n */\nexport interface ToolHandler {\n  (input: any): Promise<any> | any;\n}\n\n/**\n * Distri-specific Agent type that wraps A2A AgentCard\n */\nexport interface DistriAgent {\n  /** The name of the agent. */\n  name: string;\n\n  id: string;\n\n  /** A brief description of the agent's purpose. */\n  description?: string;\n\n  /** The version of the agent. */\n  version?: string;\n\n  /** The system prompt for the agent, if any. */\n  system_prompt?: string | null;\n\n  /** A list of MCP server definitions associated with the agent. */\n  mcp_servers?: McpDefinition[];\n\n  /** Settings related to the model used by the agent. */\n  model_settings?: ModelSettings;\n\n  /** The size of the history to maintain for the agent. */\n  history_size?: number;\n\n  /** The planning configuration for the agent, if any. */\n  plan?: any;\n\n  /** A2A-specific fields */\n  icon_url?: string;\n\n  max_iterations?: number;\n\n  skills?: AgentSkill[];\n\n  /** List of sub-agents that this agent can transfer control to */\n  sub_agents?: string[];\n\n  /** Tool approval configuration */\n  tool_approval?: ApprovalMode;\n}\n\nexport interface McpDefinition {\n  /** The filter applied to the tools in this MCP definition. */\n  filter?: string[];\n\n  /** The name of the MCP server. */\n  name: string;\n\n  /** The type of the MCP server (Tool or Agent). */\n  type?: McpServerType; // Use 'type' here instead of 'r#type'\n}\n\n/**\n * Mode for tool approval requirements\n */\nexport type ApprovalMode =\n  | { type: 'none' }\n  | { type: 'all' }\n  | { type: 'filter'; tools: string[] };\n\n/**\n * Message metadata types for tool responses and content\n */\nexport type MessageMetadata =\n  | {\n    type: 'tool_response';\n    tool_call_id: string;\n    result: any;\n  }\n  | {\n    type: 'assistant_response';\n    tool_calls: ToolCall[];\n  }\n  | {\n    type: 'plan';\n    plan: string;\n  }\n  | {\n    type: 'tool_responses';\n    results: ToolResult[];\n  };\n\n/**\n * Approval request tool name constant\n */\nexport const APPROVAL_REQUEST_TOOL_NAME = 'approval_request';\n\nexport interface ModelSettings {\n  model: string;\n  temperature: number;\n  max_tokens: number;\n  top_p: number;\n  frequency_penalty: number;\n  presence_penalty: number;\n  max_iterations: number;\n  provider: ModelProvider;\n  /** Additional parameters for the agent, if any. */\n  parameters?: any;\n\n  /** The format of the response, if specified. */\n  response_format?: any;\n}\n\nexport type McpServerType = 'tool' | 'agent';\n\nexport type ModelProvider = 'openai' | 'aigateway';\n\n/**\n * Distri Thread type for conversation management\n */\nexport interface DistriThread {\n  id: string;\n  title: string;\n  agent_id: string;\n  agent_name: string;\n  updated_at: string;\n  message_count: number;\n  last_message?: string;\n}\n\nexport interface Thread {\n  id: string;\n  title: string;\n  agent_id: string;\n  agent_name: string;\n  updated_at: string;\n  message_count: number;\n  last_message?: string;\n}\n\nexport interface ChatProps {\n  thread: Thread;\n  agent: DistriAgent;\n  onThreadUpdate?: () => void;\n}\n\n/**\n * Connection Status\n */\nexport type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';\n\n/**\n * Distri Client Configuration\n */\nexport interface DistriClientConfig {\n  baseUrl: string;\n  apiVersion?: string;\n  timeout?: number;\n  retryAttempts?: number;\n  retryDelay?: number;\n  debug?: boolean;\n  headers?: Record<string, string>;\n  interceptor?: (init?: RequestInit) => Promise<RequestInit | undefined>;\n}\n\n/**\n * Error Types\n */\nexport class DistriError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'DistriError';\n  }\n}\n\nexport class A2AProtocolError extends DistriError {\n  constructor(message: string, details?: any) {\n    super(message, 'A2A_PROTOCOL_ERROR', details);\n    this.name = 'A2AProtocolError';\n  }\n}\n\nexport class ApiError extends DistriError {\n  constructor(message: string, public statusCode: number, details?: any) {\n    super(message, 'API_ERROR', details);\n    this.name = 'ApiError';\n  }\n}\n\nexport class ConnectionError extends DistriError {\n  constructor(message: string, details?: any) {\n    super(message, 'CONNECTION_ERROR', details);\n    this.name = 'ConnectionError';\n  }\n}\n\n// Re-export A2A types for convenience\nexport type { AgentCard, Message, Task, TaskStatus, MessageSendParams, TaskStatusUpdateEvent, TaskArtifactUpdateEvent } from '@a2a-js/sdk/client';\n\nexport type A2AStreamEventData = Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent | Task;","import {\n  A2AClient,\n  Message,\n  MessageSendParams,\n  Task,\n  SendMessageResponse,\n  GetTaskResponse,\n  Part,\n\n} from '@a2a-js/sdk/client';\nimport {\n  DistriClientConfig,\n  DistriError,\n  ApiError,\n  A2AProtocolError,\n  DistriAgent,\n  DistriThread,\n  A2AStreamEventData\n} from './types';\n/**\n * Enhanced Distri Client that wraps A2AClient and adds Distri-specific features\n */\nexport class DistriClient {\n  private config: Required<DistriClientConfig>;\n  private agentClients = new Map<string, A2AClient>();\n\n  constructor(config: DistriClientConfig) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/$/, ''),\n      apiVersion: config.apiVersion || 'v1',\n      timeout: config.timeout || 30000,\n      retryAttempts: config.retryAttempts || 3,\n      retryDelay: config.retryDelay || 1000,\n      debug: config.debug || false,\n      headers: config.headers || {},\n      interceptor: config.interceptor || ((init?: RequestInit) => Promise.resolve(init))\n    };\n\n    this.debug('DistriClient initialized with config:', this.config);\n  }\n\n\n  /**\n   * Get all available agents from the Distri server\n   */\n  async getAgents(): Promise<DistriAgent[]> {\n    try {\n      const response = await this.fetch(`/agents`, {\n        headers: {\n          ...this.config.headers,\n        }\n      });\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch agents: ${response.statusText}`, response.status);\n      }\n\n      const agents: DistriAgent[] = await response.json();\n      // Temporary fix for agents without an id\n      agents.forEach(agent => {\n        if (!agent.id) {\n          agent.id = agent.name;\n        }\n      });\n\n      return agents;\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError('Failed to fetch agents', 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get specific agent by ID\n   */\n  async getAgent(agentId: string): Promise<DistriAgent> {\n    try {\n      const response = await this.fetch(`/agents/${agentId}`, {\n        headers: {\n          ...this.config.headers,\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 404) {\n          throw new ApiError(`Agent not found: ${agentId}`, 404);\n        }\n        throw new ApiError(`Failed to fetch agent: ${response.statusText}`, response.status);\n      }\n\n      const agent: DistriAgent = await response.json();\n      // If the agent doesn't have an id, set it to the agentId\n      if (!agent.id) {\n        agent.id = agentId;\n      }\n      return agent;\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch agent ${agentId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get or create A2AClient for an agent\n   */\n  private getA2AClient(agentId: string): A2AClient {\n    if (!this.agentClients.has(agentId)) {\n      // Use agent's URL from the configured baseUrl\n      const fetchFn = this.fetchAbsolute.bind(this);\n      const agentUrl = `${this.config.baseUrl}/agents/${agentId}`;\n      const client = new A2AClient(agentUrl, fetchFn);\n      this.agentClients.set(agentId, client);\n      this.debug(`Created A2AClient for agent ${agentId} at ${agentUrl}`);\n    }\n    return this.agentClients.get(agentId)!;\n  }\n\n  /**\n   * Send a message to an agent\n   */\n  async sendMessage(agentId: string, params: MessageSendParams): Promise<Message | Task> {\n    try {\n      const client = this.getA2AClient(agentId);\n\n      const response: SendMessageResponse = await client.sendMessage(params);\n\n      if ('error' in response && response.error) {\n        throw new A2AProtocolError(response.error.message, response.error);\n      }\n\n      if ('result' in response) {\n        const result = response.result;\n        this.debug(`Message sent to ${agentId}, got ${result.kind}:`, result);\n        return result;\n      }\n\n      throw new DistriError('Invalid response format', 'INVALID_RESPONSE');\n    } catch (error) {\n      if (error instanceof A2AProtocolError || error instanceof DistriError) throw error;\n      throw new DistriError(`Failed to send message to agent ${agentId}`, 'SEND_MESSAGE_ERROR', error);\n    }\n  }\n\n  /**\n   * Send a streaming message to an agent\n   */\n  async * sendMessageStream(agentId: string, params: MessageSendParams): AsyncGenerator<A2AStreamEventData> {\n    try {\n      const client = this.getA2AClient(agentId);\n      yield* await client.sendMessageStream(params);\n    } catch (error) {\n      throw new DistriError(`Failed to stream message to agent ${agentId}`, 'STREAM_MESSAGE_ERROR', error);\n    }\n  }\n\n  /**\n   * Get task details\n   */\n  async getTask(agentId: string, taskId: string): Promise<Task> {\n    try {\n      const client = this.getA2AClient(agentId);\n      const response: GetTaskResponse = await client.getTask({ id: taskId });\n\n      if ('error' in response && response.error) {\n        throw new A2AProtocolError(response.error.message, response.error);\n      }\n\n      if ('result' in response) {\n        const result = response.result;\n        this.debug(`Got task ${taskId} from ${agentId}:`, result);\n        return result;\n      }\n\n      throw new DistriError('Invalid response format', 'INVALID_RESPONSE');\n    } catch (error) {\n      if (error instanceof A2AProtocolError || error instanceof DistriError) throw error;\n      throw new DistriError(`Failed to get task ${taskId} from agent ${agentId}`, 'GET_TASK_ERROR', error);\n    }\n  }\n\n  /**\n   * Cancel a task\n   */\n  async cancelTask(agentId: string, taskId: string): Promise<void> {\n    try {\n      const client = this.getA2AClient(agentId);\n      await client.cancelTask({ id: taskId });\n      this.debug(`Cancelled task ${taskId} on agent ${agentId}`);\n    } catch (error) {\n      throw new DistriError(`Failed to cancel task ${taskId} on agent ${agentId}`, 'CANCEL_TASK_ERROR', error);\n    }\n  }\n\n  /**\n   * Get threads from Distri server\n   */\n  async getThreads(): Promise<DistriThread[]> {\n    try {\n      const response = await this.fetch(`/threads`);\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch threads: ${response.statusText}`, response.status);\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError('Failed to fetch threads', 'FETCH_ERROR', error);\n    }\n  }\n\n  async getThread(threadId: string): Promise<DistriThread> {\n    try {\n      const response = await this.fetch(`/threads/${threadId}`);\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch thread: ${response.statusText}`, response.status);\n      }\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch thread ${threadId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get thread messages\n   */\n  async getThreadMessages(threadId: string): Promise<Message[]> {\n    try {\n      const response = await this.fetch(`/threads/${threadId}/messages`);\n      if (!response.ok) {\n        if (response.status === 404) {\n          return []; // Thread not found, return empty messages\n        }\n        throw new ApiError(`Failed to fetch thread messages: ${response.statusText}`, response.status);\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch messages for thread ${threadId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get the base URL for making direct requests\n   */\n  get baseUrl(): string {\n    return this.config.baseUrl;\n  }\n\n  /**\n   * Enhanced fetch with retry logic\n   */\n  private async fetchAbsolute(url: RequestInfo | URL, initialInit?: RequestInit): Promise<Response> {\n\n    const init = await this.config.interceptor(initialInit);\n    // Construct the full URL using baseUrl\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= this.config.retryAttempts; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n        const response = await fetch(url, {\n          ...init,\n          signal: controller.signal,\n          headers: {\n            ...this.config.headers,\n            ...init?.headers\n          }\n        });\n\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < this.config.retryAttempts) {\n          this.debug(`Request failed (attempt ${attempt + 1}), retrying in ${this.config.retryDelay}ms...`);\n          await this.delay(this.config.retryDelay);\n        }\n      }\n    }\n    throw lastError!;\n  }\n\n  /**\n   * Enhanced fetch with retry logic\n   */\n  private async fetch(input: RequestInfo | URL, initialInit?: RequestInit): Promise<Response> {\n    // Construct the full URL using baseUrl\n    const url = `${this.config.baseUrl}${input}`;\n    return this.fetchAbsolute(url, initialInit);\n  }\n\n  /**\n   * Delay utility\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Debug logging\n   */\n  private debug(...args: any[]): void {\n    if (this.config.debug) {\n      console.log('[DistriClient]', ...args);\n    }\n  }\n\n  /**\n   * Helper method to create A2A messages\n   */\n  static initMessage(\n\n    parts: Part[] | string,\n    role: 'agent' | 'user' = 'user',\n    message: Omit<Partial<Message>, 'parts' | 'role' | 'kind'>\n  ): Message {\n    return {\n      messageId: message.messageId || uuidv4(),\n      taskId: message.taskId || uuidv4(),\n      contextId: message.contextId,\n      role,\n      parts: Array.isArray(parts) ? parts : [{ kind: 'text', text: parts.trim() }],\n      ...message,\n      kind: 'message'\n    };\n  }\n\n  /**\n   * Helper method to create message send parameters\n   */\n  static initMessageParams(\n    message: Message,\n    configuration?: MessageSendParams['configuration'],\n    metadata?: any\n  ): MessageSendParams {\n    return {\n      message,\n      configuration: {\n        acceptedOutputModes: ['text/plain'],\n        blocking: false, // Default to non-blocking for streaming\n        ...configuration\n      },\n      metadata\n    };\n  }\n}\nexport function uuidv4(): string {\n  if (typeof crypto?.randomUUID === 'function') {\n    return crypto.randomUUID();\n  }\n  // Fallback for older browsers\n  const array = new Uint8Array(16);\n  crypto.getRandomValues(array);\n  // Per RFC4122 v4\n  array[6] = (array[6] & 0x0f) | 0x40;\n  array[8] = (array[8] & 0x3f) | 0x80;\n  return [...array].map((b, i) =>\n    ([4, 6, 8, 10].includes(i) ? '-' : '') + b.toString(16).padStart(2, '0')\n  ).join('');\n}","import { DistriClient } from './distri-client';\nimport {\n  DistriAgent,\n  DistriTool,\n  ToolCall,\n  ToolHandler,\n  ToolResult,\n  A2AStreamEventData,\n  APPROVAL_REQUEST_TOOL_NAME\n} from './types';\nimport { Message, MessageSendParams } from '@a2a-js/sdk/client';\n\n/**\n * Configuration for Agent invoke method\n */\nexport interface InvokeConfig {\n  /** Configuration for the message */\n  configuration?: MessageSendParams['configuration'];\n  /** Context/thread ID */\n  contextId?: string;\n  /** Metadata for the requests */\n  metadata?: any;\n}\n\nexport interface ToolCallState {\n  tool_call_id: string;\n  tool_name?: string;\n  args: string;\n  result?: string;\n  running: boolean;\n}\n\n/**\n * Result from agent invoke\n */\nexport interface InvokeResult {\n  /** Final response message */\n  message?: Message;\n  /** Task if created */\n  task?: any;\n  /** Whether the response was streamed */\n  streamed: boolean;\n}\n\n/**\n * Enhanced Agent class with simple tool system following AG-UI pattern\n */\nexport class Agent {\n  private client: DistriClient;\n  private agentDefinition: DistriAgent;\n  private tools: Map<string, ToolHandler> = new Map();\n\n  constructor(agentDefinition: DistriAgent, client: DistriClient) {\n    this.agentDefinition = agentDefinition;\n    this.client = client;\n    // Initialize with built-in tools\n    this.initializeBuiltinTools();\n  }\n\n  /**\n   * Initialize built-in tools\n   */\n  private initializeBuiltinTools() {\n    this.addTool({\n      name: APPROVAL_REQUEST_TOOL_NAME,\n      description: 'Request user approval for actions',\n      parameters: {\n        type: 'object',\n        properties: {\n          prompt: { type: 'string', description: 'Approval prompt to show user' },\n          action: { type: 'string', description: 'Action requiring approval' }\n        },\n        required: ['prompt']\n      },\n      handler: async (input: any) => {\n        const userInput = prompt(input.prompt || 'Please provide input:');\n        return { approved: !!userInput, input: userInput };\n      }\n    });\n  }\n\n  /**\n   * Add a tool to the agent (AG-UI style)\n   */\n  addTool(tool: DistriTool): void {\n    this.tools.set(tool.name, tool.handler);\n  }\n\n  /**\n   * Add multiple tools at once\n   */\n  addTools(tools: DistriTool[]): void {\n    tools.forEach(tool => this.addTool(tool));\n  }\n\n  /**\n   * Remove a tool\n   */\n  removeTool(toolName: string): void {\n    this.tools.delete(toolName);\n  }\n\n  /**\n   * Get all registered tools\n   */\n  getTools(): string[] {\n    return Array.from(this.tools.keys());\n  }\n\n  /**\n   * Check if a tool is registered\n   */\n  hasTool(toolName: string): boolean {\n    return this.tools.has(toolName);\n  }\n\n  /**\n   * Execute a tool call\n   */\n  async executeTool(toolCall: ToolCall): Promise<ToolResult> {\n    const handler = this.tools.get(toolCall.tool_name);\n    \n    if (!handler) {\n      return {\n        tool_call_id: toolCall.tool_call_id,\n        result: null,\n        success: false,\n        error: `Tool '${toolCall.tool_name}' not found`\n      };\n    }\n\n    try {\n      const result = await handler(toolCall.input);\n      return {\n        tool_call_id: toolCall.tool_call_id,\n        result,\n        success: true\n      };\n    } catch (error) {\n      return {\n        tool_call_id: toolCall.tool_call_id,\n        result: null,\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\n   * Get tool definitions for context metadata\n   */\n  getToolDefinitions(): Record<string, any> {\n    const definitions: Record<string, any> = {};\n    \n    // Note: We only send tool names to the backend since handlers are frontend-only\n    this.tools.forEach((_handler, name) => {\n      definitions[name] = { name };\n    });\n    \n    return definitions;\n  }\n\n  /**\n   * Get agent information\n   */\n  get id(): string {\n    return this.agentDefinition.id;\n  }\n\n  get name(): string {\n    return this.agentDefinition.name;\n  }\n\n  get description(): string | undefined {\n    return this.agentDefinition.description;\n  }\n\n  /**\n   * Fetch messages for a thread (public method for useChat)\n   */\n  async getThreadMessages(threadId: string): Promise<Message[]> {\n    return this.client.getThreadMessages(threadId);\n  }\n\n  /**\n   * Direct (non-streaming) invoke\n   */\n  public async invoke(params: MessageSendParams): Promise<Message> {\n    // Inject tool definitions into metadata\n    const enhancedParams = this.enhanceParamsWithTools(params);\n    return await this.client.sendMessage(this.agentDefinition.id, enhancedParams) as Message;\n  }\n\n  /**\n   * Streaming invoke\n   */\n  public async invokeStream(params: MessageSendParams): Promise<AsyncGenerator<A2AStreamEventData>> {\n    // Inject tool definitions into metadata\n    const enhancedParams = this.enhanceParamsWithTools(params);\n    return this.client.sendMessageStream(this.agentDefinition.id, enhancedParams) as AsyncGenerator<A2AStreamEventData>;\n  }\n\n  /**\n   * Enhance message params with tool definitions\n   */\n  private enhanceParamsWithTools(params: MessageSendParams): MessageSendParams {\n    const toolDefinitions = this.getToolDefinitions();\n    \n    return {\n      ...params,\n      metadata: {\n        ...params.metadata,\n        tools: Object.keys(toolDefinitions).length > 0 ? toolDefinitions : undefined\n      }\n    };\n  }\n\n  /**\n   * Create an agent instance from an agent ID\n   */\n  static async create(agentId: string, client: DistriClient): Promise<Agent> {\n    const agentDefinition = await client.getAgent(agentId);\n    return new Agent(agentDefinition, client);\n  }\n\n  /**\n   * List all available agents\n   */\n  static async list(client: DistriClient): Promise<Agent[]> {\n    const agentDefinitions = await client.getAgents();\n    return agentDefinitions.map(def => new Agent(def, client));\n  }\n}\n"],"mappings":"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","names":[]}