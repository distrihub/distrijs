{"version":3,"sources":["../src/types.ts","../../../node_modules/.pnpm/@a2a-js+sdk@https+++codeload.github.com+v3g42+a2a-js+tar.gz+51444c9/node_modules/@a2a-js/sdk/dist/chunk-CUGIRVQB.js","../src/distri-client.ts","../src/agent.ts"],"sourcesContent":["// Distri Framework Types - Based on A2A Protocol and SSE\nimport { AgentSkill, Message, Task, TaskArtifactUpdateEvent, TaskStatusUpdateEvent } from '@a2a-js/sdk/client';\n\n/**\n * Distri-specific Agent type that wraps A2A AgentCard\n */\nexport interface DistriAgent {\n  /** The name of the agent. */\n  name: string;\n\n  id: string;\n\n  /** A brief description of the agent's purpose. */\n  description?: string;\n\n  /** The version of the agent. */\n  version?: string;\n\n  /** The system prompt for the agent, if any. */\n  system_prompt?: string | null;\n\n  /** A list of MCP server definitions associated with the agent. */\n  mcp_servers?: McpDefinition[];\n\n  /** Settings related to the model used by the agent. */\n  model_settings?: ModelSettings;\n\n  /** The size of the history to maintain for the agent. */\n  history_size?: number;\n\n  /** The planning configuration for the agent, if any. */\n  plan?: any;\n\n  /** A2A-specific fields */\n  icon_url?: string;\n\n  max_iterations?: number;\n\n  skills?: AgentSkill[];\n\n  /** List of sub-agents that this agent can transfer control to */\n  sub_agents?: string[];\n\n  /** External tools that are handled by the frontend */\n  external_tools?: ExternalTool[];\n\n  /** Tool approval configuration */\n  tool_approval?: ApprovalMode;\n}\n\nexport interface McpDefinition {\n  /** The filter applied to the tools in this MCP definition. */\n  filter?: string[];\n\n  /** The name of the MCP server. */\n  name: string;\n\n  /** The type of the MCP server (Tool or Agent). */\n  type?: McpServerType; // Use 'type' here instead of 'r#type'\n}\n\n/**\n * External tool definition\n */\nexport interface ExternalTool {\n  name: string;\n  description: string;\n  input_schema: any;\n}\n\n/**\n * Mode for tool approval requirements\n */\nexport type ApprovalMode =\n  | { type: 'none' }\n  | { type: 'all' }\n  | { type: 'filter'; tools: string[] };\n\n/**\n * Tool call definition\n */\nexport interface ToolCall {\n  tool_call_id: string;\n  tool_name: string;\n  input: string;\n}\n\n/**\n * Message metadata types for external tools and approval system\n */\nexport type MessageMetadata =\n  | {\n    type: 'tool_response';\n    tool_call_id: string;\n    result: any;\n  }\n  | {\n    type: 'tool_calls';\n    tool_calls: ToolCall[];\n  }\n  | {\n    type: 'external_tool_calls';\n    tool_calls: ToolCall[];\n    requires_approval: boolean;\n  };\n\n/**\n * Approval request tool name constant\n */\nexport const APPROVAL_REQUEST_TOOL_NAME = 'approval_request';\n\nexport interface ModelSettings {\n  model: string;\n  temperature: number;\n  max_tokens: number;\n  top_p: number;\n  frequency_penalty: number;\n  presence_penalty: number;\n  max_iterations: number;\n  provider: ModelProvider;\n  /** Additional parameters for the agent, if any. */\n  parameters?: any;\n\n  /** The format of the response, if specified. */\n  response_format?: any;\n}\n\nexport type McpServerType = 'tool' | 'agent';\n\nexport type ModelProvider = 'openai' | 'aigateway';\n\n/**\n * Distri Thread type for conversation management\n */\nexport interface DistriThread {\n  id: string;\n  title: string;\n  agent_id: string;\n  agent_name: string;\n  updated_at: string;\n  message_count: number;\n  last_message?: string;\n}\n\nexport interface Thread {\n  id: string;\n  title: string;\n  agent_id: string;\n  agent_name: string;\n  updated_at: string;\n  message_count: number;\n  last_message?: string;\n}\n\nexport interface ChatProps {\n  thread: Thread;\n  agent: DistriAgent;\n  onThreadUpdate?: () => void;\n}\n\n/**\n * Connection Status\n */\nexport type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';\n\n/**\n * Distri Client Configuration\n */\nexport interface DistriClientConfig {\n  baseUrl: string;\n  apiVersion?: string;\n  timeout?: number;\n  retryAttempts?: number;\n  retryDelay?: number;\n  debug?: boolean;\n  headers?: Record<string, string>;\n  interceptor?: (init?: RequestInit) => Promise<RequestInit | undefined>;\n}\n\n/**\n * Error Types\n */\nexport class DistriError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'DistriError';\n  }\n}\n\nexport class A2AProtocolError extends DistriError {\n  constructor(message: string, details?: any) {\n    super(message, 'A2A_PROTOCOL_ERROR', details);\n    this.name = 'A2AProtocolError';\n  }\n}\n\nexport class ApiError extends DistriError {\n  constructor(message: string, public statusCode: number, details?: any) {\n    super(message, 'API_ERROR', details);\n    this.name = 'ApiError';\n  }\n}\n\nexport class ConnectionError extends DistriError {\n  constructor(message: string, details?: any) {\n    super(message, 'CONNECTION_ERROR', details);\n    this.name = 'ConnectionError';\n  }\n}\n\n// Re-export A2A types for convenience\nexport type { AgentCard, Message, Task, TaskStatus, MessageSendParams, TaskStatusUpdateEvent, TaskArtifactUpdateEvent } from '@a2a-js/sdk/client';\n\nexport type A2AStreamEventData = Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent | Task;","// src/client/client.ts\nvar A2AClient = class {\n  agentBaseUrl;\n  agentCardPromise;\n  requestIdCounter = 1;\n  serviceEndpointUrl;\n  // To be populated from AgentCard after fetching\n  fetchFn;\n  /**\n   * Constructs an A2AClient instance.\n   * It initiates fetching the agent card from the provided agent baseUrl.\n   * The Agent Card is expected at `${agentBaseUrl}/.well-known/agent.json`.\n   * The `url` field from the Agent Card will be used as the RPC service endpoint.\n   * @param agentBaseUrl The base URL of the A2A agent (e.g., https://agent.example.com).\n   */\n  constructor(agentBaseUrl, fetchFn) {\n    this.agentBaseUrl = agentBaseUrl.replace(/\\/$/, \"\");\n    this.fetchFn = fetchFn || globalThis.fetch;\n    this.agentCardPromise = this._fetchAndCacheAgentCard();\n  }\n  /**\n   * Fetches the Agent Card from the agent's well-known URI and caches its service endpoint URL.\n   * This method is called by the constructor.\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async _fetchAndCacheAgentCard() {\n    const agentCardUrl = `${this.agentBaseUrl}/.well-known/agent.json`;\n    try {\n      const response = await this.fetchFn(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      const agentCard = await response.json();\n      if (!agentCard.url) {\n        throw new Error(\"Fetched Agent Card does not contain a valid 'url' for the service endpoint.\");\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      return agentCard;\n    } catch (error) {\n      console.error(\"Error fetching or parsing Agent Card:\");\n      throw error;\n    }\n  }\n  /**\n   * Retrieves the Agent Card.\n   * If an `agentBaseUrl` is provided, it fetches the card from that specific URL.\n   * Otherwise, it returns the card fetched and cached during client construction.\n   * @param agentBaseUrl Optional. The base URL of the agent to fetch the card from.\n   * If provided, this will fetch a new card, not use the cached one from the constructor's URL.\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async getAgentCard(agentBaseUrl) {\n    if (agentBaseUrl) {\n      const specificAgentBaseUrl = agentBaseUrl.replace(/\\/$/, \"\");\n      const agentCardUrl = `${specificAgentBaseUrl}/.well-known/agent.json`;\n      const response = await this.fetchFn(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      return await response.json();\n    }\n    return this.agentCardPromise;\n  }\n  /**\n   * Gets the RPC service endpoint URL. Ensures the agent card has been fetched first.\n   * @returns A Promise that resolves to the service endpoint URL string.\n   */\n  async _getServiceEndpoint() {\n    if (this.serviceEndpointUrl) {\n      return this.serviceEndpointUrl;\n    }\n    await this.agentCardPromise;\n    if (!this.serviceEndpointUrl) {\n      throw new Error(\"Agent Card URL for RPC endpoint is not available. Fetching might have failed.\");\n    }\n    return this.serviceEndpointUrl;\n  }\n  /**\n   * Helper method to make a generic JSON-RPC POST request.\n   * @param method The RPC method name.\n   * @param params The parameters for the RPC method.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async _postRpcRequest(method, params) {\n    const endpoint = await this._getServiceEndpoint();\n    const requestId = this.requestIdCounter++;\n    const rpcRequest = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      // Cast because TParams structure varies per method\n      id: requestId\n    };\n    const httpResponse = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n        // Expect JSON response for non-streaming requests\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!httpResponse.ok) {\n      let errorBodyText = \"(empty or non-JSON response)\";\n      try {\n        errorBodyText = await httpResponse.text();\n        const errorJson = JSON.parse(errorBodyText);\n        if (!errorJson.jsonrpc && errorJson.error) {\n          throw new Error(`RPC error for ${method}: ${errorJson.error.message} (Code: ${errorJson.error.code}, HTTP Status: ${httpResponse.status}) Data: ${JSON.stringify(errorJson.error.data)}`);\n        } else if (!errorJson.jsonrpc) {\n          throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"RPC error for\") || e.message.startsWith(\"HTTP error for\")) throw e;\n        throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n      }\n    }\n    const rpcResponse = await httpResponse.json();\n    if (rpcResponse.id !== requestId) {\n      console.error(`CRITICAL: RPC response ID mismatch for method ${method}. Expected ${requestId}, got ${rpcResponse.id}. This may lead to incorrect response handling.`);\n    }\n    return rpcResponse;\n  }\n  /**\n   * Sends a message to the agent.\n   * The behavior (blocking/non-blocking) and push notification configuration\n   * are specified within the `params.configuration` object.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * @param params The parameters for sending the message, including the message content and configuration.\n   * @returns A Promise resolving to SendMessageResponse, which can be a Message, Task, or an error.\n   */\n  async sendMessage(params) {\n    return this._postRpcRequest(\"message/send\", params);\n  }\n  /**\n   * Sends a message to the agent and streams back responses using Server-Sent Events (SSE).\n   * Push notification configuration can be specified in `params.configuration`.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params The parameters for sending the message.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   * The generator throws an error if streaming is not supported or if an HTTP/SSE error occurs.\n   */\n  async *sendMessageStream(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (AgentCard.capabilities.streaming is not true).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // This is the initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"message/stream\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n        // Crucial for SSE\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Sets or updates the push notification configuration for a given task.\n   * Requires the agent to support push notifications (`capabilities.pushNotifications: true` in AgentCard).\n   * @param params Parameters containing the taskId and the TaskPushNotificationConfig.\n   * @returns A Promise resolving to SetTaskPushNotificationConfigResponse.\n   */\n  async setTaskPushNotificationConfig(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.pushNotifications) {\n      throw new Error(\"Agent does not support push notifications (AgentCard.capabilities.pushNotifications is not true).\");\n    }\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/set\",\n      params\n    );\n  }\n  /**\n   * Gets the push notification configuration for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to GetTaskPushNotificationConfigResponse.\n   */\n  async getTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/get\",\n      params\n    );\n  }\n  /**\n   * Retrieves a task by its ID.\n   * @param params Parameters containing the taskId and optional historyLength.\n   * @returns A Promise resolving to GetTaskResponse, which contains the Task object or an error.\n   */\n  async getTask(params) {\n    return this._postRpcRequest(\"tasks/get\", params);\n  }\n  /**\n   * Cancels a task by its ID.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to CancelTaskResponse, which contains the updated Task object or an error.\n   */\n  async cancelTask(params) {\n    return this._postRpcRequest(\"tasks/cancel\", params);\n  }\n  /**\n   * Resubscribes to a task's event stream using Server-Sent Events (SSE).\n   * This is used if a previous SSE connection for an active task was broken.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params Parameters containing the taskId.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   */\n  async *resubscribeTask(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (required for tasks/resubscribe).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // Initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"tasks/resubscribe\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this.fetchFn(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream on resubscribe. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Parses an HTTP response body as an A2A Server-Sent Event stream.\n   * Each 'data' field of an SSE event is expected to be a JSON-RPC 2.0 Response object,\n   * specifically a SendStreamingMessageResponse (or similar structure for resubscribe).\n   * @param response The HTTP Response object whose body is the SSE stream.\n   * @param originalRequestId The ID of the client's JSON-RPC request that initiated this stream.\n   * Used to validate the `id` in the streamed JSON-RPC responses.\n   * @returns An AsyncGenerator yielding the `result` field of each valid JSON-RPC success response from the stream.\n   */\n  async *_parseA2ASseStream(response, originalRequestId) {\n    if (!response.body) {\n      throw new Error(\"SSE response body is undefined. Cannot read stream.\");\n    }\n    const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();\n    let buffer = \"\";\n    let eventDataBuffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          if (eventDataBuffer.trim()) {\n            const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n            yield result;\n          }\n          break;\n        }\n        buffer += value;\n        let lineEndIndex;\n        while ((lineEndIndex = buffer.indexOf(\"\\n\")) >= 0) {\n          const line = buffer.substring(0, lineEndIndex).trim();\n          buffer = buffer.substring(lineEndIndex + 1);\n          if (line === \"\") {\n            if (eventDataBuffer) {\n              const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n              yield result;\n              eventDataBuffer = \"\";\n            }\n          } else if (line.startsWith(\"data:\")) {\n            eventDataBuffer += line.substring(5).trimStart() + \"\\n\";\n          } else if (line.startsWith(\":\")) {\n          } else if (line.includes(\":\")) {\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error reading or parsing SSE stream:\", error.message);\n      throw error;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  /**\n   * Processes a single SSE event's data string, expecting it to be a JSON-RPC response.\n   * @param jsonData The string content from one or more 'data:' lines of an SSE event.\n   * @param originalRequestId The ID of the client's request that initiated the stream.\n   * @returns The `result` field of the parsed JSON-RPC success response.\n   * @throws Error if data is not valid JSON, not a valid JSON-RPC response, an error response, or ID mismatch.\n   */\n  _processSseEventData(jsonData, originalRequestId) {\n    if (!jsonData.trim()) {\n      throw new Error(\"Attempted to process empty SSE event data.\");\n    }\n    try {\n      const sseJsonRpcResponse = JSON.parse(jsonData.replace(/\\n$/, \"\"));\n      const a2aStreamResponse = sseJsonRpcResponse;\n      if (a2aStreamResponse.id !== originalRequestId) {\n        console.warn(`SSE Event's JSON-RPC response ID mismatch. Client request ID: ${originalRequestId}, event response ID: ${a2aStreamResponse.id}.`);\n      }\n      if (this.isErrorResponse(a2aStreamResponse)) {\n        const err = a2aStreamResponse.error;\n        throw new Error(`SSE event contained an error: ${err.message} (Code: ${err.code}) Data: ${JSON.stringify(err.data)}`);\n      }\n      if (!(\"result\" in a2aStreamResponse) || typeof a2aStreamResponse.result === \"undefined\") {\n        throw new Error(`SSE event JSON-RPC response is missing 'result' field. Data: ${jsonData}`);\n      }\n      const successResponse = a2aStreamResponse;\n      return successResponse.result;\n    } catch (e) {\n      if (e.message.startsWith(\"SSE event contained an error\") || e.message.startsWith(\"SSE event JSON-RPC response is missing 'result' field\")) {\n        throw e;\n      }\n      console.error(\"Failed to parse SSE event data string or unexpected JSON-RPC structure:\", jsonData, e);\n      throw new Error(`Failed to parse SSE event data: \"${jsonData.substring(0, 100)}...\". Original error: ${e.message}`);\n    }\n  }\n  isErrorResponse(response) {\n    return \"error\" in response;\n  }\n};\n\nexport {\n  A2AClient\n};\n","import {\n  A2AClient,\n  Message,\n  MessageSendParams,\n  Task,\n  SendMessageResponse,\n  GetTaskResponse,\n\n} from '@a2a-js/sdk/client';\nimport {\n  DistriClientConfig,\n  DistriError,\n  ApiError,\n  A2AProtocolError,\n  DistriAgent,\n  DistriThread,\n  A2AStreamEventData\n} from './types';\n/**\n * Enhanced Distri Client that wraps A2AClient and adds Distri-specific features\n */\nexport class DistriClient {\n  private config: Required<DistriClientConfig>;\n  private agentClients = new Map<string, A2AClient>();\n\n  constructor(config: DistriClientConfig) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/$/, ''),\n      apiVersion: config.apiVersion || 'v1',\n      timeout: config.timeout || 30000,\n      retryAttempts: config.retryAttempts || 3,\n      retryDelay: config.retryDelay || 1000,\n      debug: config.debug || false,\n      headers: config.headers || {},\n      interceptor: config.interceptor || ((init?: RequestInit) => Promise.resolve(init))\n    };\n\n    this.debug('DistriClient initialized with config:', this.config);\n  }\n\n\n  /**\n   * Get all available agents from the Distri server\n   */\n  async getAgents(): Promise<DistriAgent[]> {\n    try {\n      const response = await this.fetch(`/agents`, {\n        headers: {\n          ...this.config.headers,\n        }\n      });\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch agents: ${response.statusText}`, response.status);\n      }\n\n      const agents: DistriAgent[] = await response.json();\n      // Temporary fix for agents without an id\n      agents.forEach(agent => {\n        if (!agent.id) {\n          agent.id = agent.name;\n        }\n      });\n\n      return agents;\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError('Failed to fetch agents', 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get specific agent by ID\n   */\n  async getAgent(agentId: string): Promise<DistriAgent> {\n    try {\n      const response = await this.fetch(`/agents/${agentId}`, {\n        headers: {\n          ...this.config.headers,\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 404) {\n          throw new ApiError(`Agent not found: ${agentId}`, 404);\n        }\n        throw new ApiError(`Failed to fetch agent: ${response.statusText}`, response.status);\n      }\n\n      const agent: DistriAgent = await response.json();\n      // If the agent doesn't have an id, set it to the agentId\n      if (!agent.id) {\n        agent.id = agentId;\n      }\n      return agent;\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch agent ${agentId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get or create A2AClient for an agent\n   */\n  private getA2AClient(agentId: string): A2AClient {\n    if (!this.agentClients.has(agentId)) {\n      // Use agent's URL from the configured baseUrl\n      const fetchFn = this.fetchAbsolute.bind(this);\n      const agentUrl = `${this.config.baseUrl}/agents/${agentId}`;\n      // Custom A2AClient accepts fetchFn as second parameter\n      const client = new (A2AClient as any)(agentUrl, fetchFn);\n      this.agentClients.set(agentId, client);\n      this.debug(`Created A2AClient for agent ${agentId} at ${agentUrl}`);\n    }\n    return this.agentClients.get(agentId)!;\n  }\n\n  /**\n   * Send a message to an agent\n   */\n  async sendMessage(agentId: string, params: MessageSendParams): Promise<Message | Task> {\n    try {\n      const client = this.getA2AClient(agentId);\n\n      const response: SendMessageResponse = await client.sendMessage(params);\n\n      if ('error' in response && response.error) {\n        throw new A2AProtocolError(response.error.message, response.error);\n      }\n\n      if ('result' in response) {\n        const result = response.result;\n        this.debug(`Message sent to ${agentId}, got ${result.kind}:`, result);\n        return result;\n      }\n\n      throw new DistriError('Invalid response format', 'INVALID_RESPONSE');\n    } catch (error) {\n      if (error instanceof A2AProtocolError || error instanceof DistriError) throw error;\n      throw new DistriError(`Failed to send message to agent ${agentId}`, 'SEND_MESSAGE_ERROR', error);\n    }\n  }\n\n  /**\n   * Send a streaming message to an agent\n   */\n  async * sendMessageStream(agentId: string, params: MessageSendParams): AsyncGenerator<A2AStreamEventData> {\n    try {\n      const client = this.getA2AClient(agentId);\n      yield* await client.sendMessageStream(params);\n    } catch (error) {\n      throw new DistriError(`Failed to stream message to agent ${agentId}`, 'STREAM_MESSAGE_ERROR', error);\n    }\n  }\n\n  /**\n   * Get task details\n   */\n  async getTask(agentId: string, taskId: string): Promise<Task> {\n    try {\n      const client = this.getA2AClient(agentId);\n      const response: GetTaskResponse = await client.getTask({ id: taskId });\n\n      if ('error' in response && response.error) {\n        throw new A2AProtocolError(response.error.message, response.error);\n      }\n\n      if ('result' in response) {\n        const result = response.result;\n        this.debug(`Got task ${taskId} from ${agentId}:`, result);\n        return result;\n      }\n\n      throw new DistriError('Invalid response format', 'INVALID_RESPONSE');\n    } catch (error) {\n      if (error instanceof A2AProtocolError || error instanceof DistriError) throw error;\n      throw new DistriError(`Failed to get task ${taskId} from agent ${agentId}`, 'GET_TASK_ERROR', error);\n    }\n  }\n\n  /**\n   * Cancel a task\n   */\n  async cancelTask(agentId: string, taskId: string): Promise<void> {\n    try {\n      const client = this.getA2AClient(agentId);\n      await client.cancelTask({ id: taskId });\n      this.debug(`Cancelled task ${taskId} on agent ${agentId}`);\n    } catch (error) {\n      throw new DistriError(`Failed to cancel task ${taskId} on agent ${agentId}`, 'CANCEL_TASK_ERROR', error);\n    }\n  }\n\n  /**\n   * Get threads from Distri server\n   */\n  async getThreads(): Promise<DistriThread[]> {\n    try {\n      const response = await this.fetch(`/threads`);\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch threads: ${response.statusText}`, response.status);\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError('Failed to fetch threads', 'FETCH_ERROR', error);\n    }\n  }\n\n  async getThread(threadId: string): Promise<DistriThread> {\n    try {\n      const response = await this.fetch(`/threads/${threadId}`);\n      if (!response.ok) {\n        throw new ApiError(`Failed to fetch thread: ${response.statusText}`, response.status);\n      }\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch thread ${threadId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get thread messages\n   */\n  async getThreadMessages(threadId: string): Promise<Message[]> {\n    try {\n      const response = await this.fetch(`/threads/${threadId}/messages`);\n      if (!response.ok) {\n        if (response.status === 404) {\n          return []; // Thread not found, return empty messages\n        }\n        throw new ApiError(`Failed to fetch thread messages: ${response.statusText}`, response.status);\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof ApiError) throw error;\n      throw new DistriError(`Failed to fetch messages for thread ${threadId}`, 'FETCH_ERROR', error);\n    }\n  }\n\n  /**\n   * Get the base URL for making direct requests\n   */\n  get baseUrl(): string {\n    return this.config.baseUrl;\n  }\n\n  /**\n   * Enhanced fetch with retry logic\n   */\n  private async fetchAbsolute(url: RequestInfo | URL, initialInit?: RequestInit): Promise<Response> {\n\n    const init = await this.config.interceptor(initialInit);\n    // Construct the full URL using baseUrl\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= this.config.retryAttempts; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n        const response = await fetch(url, {\n          ...init,\n          signal: controller.signal,\n          headers: {\n            ...this.config.headers,\n            ...init?.headers\n          }\n        });\n\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < this.config.retryAttempts) {\n          this.debug(`Request failed (attempt ${attempt + 1}), retrying in ${this.config.retryDelay}ms...`);\n          await this.delay(this.config.retryDelay);\n        }\n      }\n    }\n    throw lastError!;\n  }\n\n  /**\n   * Enhanced fetch with retry logic\n   */\n  private async fetch(input: RequestInfo | URL, initialInit?: RequestInit): Promise<Response> {\n    // Construct the full URL using baseUrl\n    const url = `${this.config.baseUrl}${input}`;\n    return this.fetchAbsolute(url, initialInit);\n  }\n\n  /**\n   * Delay utility\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Debug logging\n   */\n  private debug(...args: any[]): void {\n    if (this.config.debug) {\n      console.log('[DistriClient]', ...args);\n    }\n  }\n\n  /**\n   * Helper method to create A2A messages\n   */\n  static initMessage(\n\n    input: string,\n    role: 'agent' | 'user' = 'user',\n    contextId?: string,\n    messageId?: string,\n    taskId?: string\n  ): Message {\n    return {\n      messageId: messageId || uuidv4(),\n      role,\n      parts: [{ kind: 'text', text: input.trim() }],\n      contextId,\n      taskId: taskId || uuidv4(),\n      kind: 'message'\n    };\n  }\n\n  /**\n   * Helper method to create message send parameters\n   */\n  static initMessageParams(\n    message: Message,\n    configuration?: MessageSendParams['configuration']\n  ): MessageSendParams {\n    return {\n      message,\n      configuration: {\n        acceptedOutputModes: ['text/plain'],\n        blocking: false, // Default to non-blocking for streaming\n        ...configuration\n      }\n    };\n  }\n}\nexport function uuidv4(): string {\n  if (typeof crypto?.randomUUID === 'function') {\n    return crypto.randomUUID();\n  }\n  // Fallback for older browsers\n  const array = new Uint8Array(16);\n  crypto.getRandomValues(array);\n  // Per RFC4122 v4\n  array[6] = (array[6] & 0x0f) | 0x40;\n  array[8] = (array[8] & 0x3f) | 0x80;\n  return [...array].map((b, i) =>\n    ([4, 6, 8, 10].includes(i) ? '-' : '') + b.toString(16).padStart(2, '0')\n  ).join('');\n}","import { DistriClient } from './distri-client';\nimport { \n  DistriAgent, \n  MessageMetadata, \n  ToolCall, \n  ExternalTool, \n  APPROVAL_REQUEST_TOOL_NAME,\n  A2AStreamEventData\n} from './types';\nimport { Message, MessageSendParams } from '@a2a-js/sdk/client';\n\n/**\n * Configuration for Agent invoke method\n */\nexport interface InvokeConfig {\n  /** Whether to stream responses */\n  stream?: boolean;\n  /** Configuration for the message */\n  configuration?: MessageSendParams['configuration'];\n  /** Context/thread ID */\n  contextId?: string;\n  /** External tool handlers */\n  externalToolHandlers?: Record<string, ExternalToolHandler>;\n  /** Approval handler for approval requests */\n  approvalHandler?: ApprovalHandler;\n}\n\n/**\n * External tool handler function\n */\nexport type ExternalToolHandler = (toolCall: ToolCall) => Promise<any>;\n\n/**\n * Approval handler function\n */\nexport type ApprovalHandler = (toolCalls: ToolCall[], reason?: string) => Promise<boolean>;\n\n/**\n * Result from agent invoke\n */\nexport interface InvokeResult {\n  /** Final response message */\n  message?: Message;\n  /** Task if created */\n  task?: any;\n  /** Whether the response was streamed */\n  streamed: boolean;\n}\n\n/**\n * Stream response from agent invoke\n */\nexport interface InvokeStreamResult {\n  /** Async generator for streaming events */\n  stream: AsyncGenerator<A2AStreamEventData>;\n  /** Method to handle external tools and approval requests */\n  handleExternalTools: (handler: ExternalToolHandler, approvalHandler?: ApprovalHandler) => Promise<void>;\n}\n\n/**\n * Enhanced Agent class with nice API\n */\nexport class Agent {\n  private client: DistriClient;\n  private agentDefinition: DistriAgent;\n\n  constructor(agentDefinition: DistriAgent, client: DistriClient) {\n    this.agentDefinition = agentDefinition;\n    this.client = client;\n  }\n\n  /**\n   * Get agent information\n   */\n  get id(): string {\n    return this.agentDefinition.id;\n  }\n\n  get name(): string {\n    return this.agentDefinition.name;\n  }\n\n  get description(): string | undefined {\n    return this.agentDefinition.description;\n  }\n\n  get externalTools(): ExternalTool[] {\n    return this.agentDefinition.external_tools || [];\n  }\n\n  /**\n   * Invoke the agent with a message\n   */\n  async invoke(input: string, config: InvokeConfig = {}): Promise<InvokeResult | InvokeStreamResult> {\n    const userMessage = DistriClient.initMessage(input, 'user', config.contextId);\n    const params = DistriClient.initMessageParams(userMessage, config.configuration);\n\n    if (config.stream) {\n      return this.invokeStream(params);\n    } else {\n      return this.invokeDirect(params, config);\n    }\n  }\n\n  /**\n   * Direct (non-streaming) invoke\n   */\n  private async invokeDirect(params: MessageSendParams, config: InvokeConfig): Promise<InvokeResult> {\n    let result = await this.client.sendMessage(this.agentDefinition.id, params);\n\n    // Handle external tools if they exist in the response\n    if (result.kind === 'message') {\n      result = await this.handleMessageExternalTools(result, config);\n    }\n\n    return {\n      message: result.kind === 'message' ? result : undefined,\n      task: result.kind === 'task' ? result : undefined,\n      streamed: false\n    };\n  }\n\n  /**\n   * Streaming invoke\n   */\n  private async invokeStream(params: MessageSendParams): Promise<InvokeStreamResult> {\n    const stream = this.client.sendMessageStream(this.agentDefinition.id, params);\n\n    return {\n      stream,\n      handleExternalTools: async (handler: ExternalToolHandler, approvalHandler?: ApprovalHandler) => {\n        await this.handleStreamExternalTools(stream, handler, approvalHandler);\n      }\n    };\n  }\n\n  /**\n   * Handle external tools in a message response\n   */\n  private async handleMessageExternalTools(message: Message, config: InvokeConfig): Promise<Message> {\n    // Check for external tool calls in message metadata\n    if (message.metadata) {\n      const metadata = message.metadata as any;\n      \n      if (metadata.type === 'external_tool_calls') {\n        const toolCalls: ToolCall[] = metadata.tool_calls;\n        const requiresApproval: boolean = metadata.requires_approval;\n\n        // Handle approval if required\n        if (requiresApproval && config.approvalHandler) {\n          const approved = await config.approvalHandler(toolCalls);\n          if (!approved) {\n            throw new Error('Tool execution cancelled by user');\n          }\n        }\n\n        // Execute external tools\n        for (const toolCall of toolCalls) {\n          if (toolCall.tool_name === APPROVAL_REQUEST_TOOL_NAME) {\n            await this.handleApprovalRequest(toolCall, config.approvalHandler);\n          } else {\n            await this.handleExternalTool(toolCall, config.externalToolHandlers);\n          }\n        }\n      }\n    }\n\n    return message;\n  }\n\n  /**\n   * Handle external tools in a stream\n   */\n  private async handleStreamExternalTools(\n    stream: AsyncGenerator<A2AStreamEventData>, \n    handler: ExternalToolHandler, \n    approvalHandler?: ApprovalHandler\n  ): Promise<void> {\n    for await (const event of stream) {\n      if (event.kind === 'message') {\n        const message = event as Message;\n        if (message.metadata) {\n          const metadata = message.metadata as any;\n          \n          if (metadata.type === 'external_tool_calls') {\n            const toolCalls: ToolCall[] = metadata.tool_calls;\n            const requiresApproval: boolean = metadata.requires_approval;\n\n            // Handle approval if required\n            if (requiresApproval && approvalHandler) {\n              const approved = await approvalHandler(toolCalls);\n              if (!approved) {\n                throw new Error('Tool execution cancelled by user');\n              }\n            }\n\n            // Execute external tools\n            for (const toolCall of toolCalls) {\n              if (toolCall.tool_name === APPROVAL_REQUEST_TOOL_NAME) {\n                await this.handleApprovalRequest(toolCall, approvalHandler);\n              } else {\n                const result = await handler(toolCall);\n                await this.sendToolResponse(toolCall.tool_call_id, result);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle a single external tool call\n   */\n  private async handleExternalTool(toolCall: ToolCall, handlers?: Record<string, ExternalToolHandler>): Promise<any> {\n    if (!handlers || !handlers[toolCall.tool_name]) {\n      throw new Error(`No handler found for external tool: ${toolCall.tool_name}`);\n    }\n\n    const result = await handlers[toolCall.tool_name](toolCall);\n    await this.sendToolResponse(toolCall.tool_call_id, result);\n    return result;\n  }\n\n  /**\n   * Handle approval request\n   */\n  private async handleApprovalRequest(toolCall: ToolCall, approvalHandler?: ApprovalHandler): Promise<void> {\n    if (!approvalHandler) {\n      throw new Error('Approval handler required for approval requests');\n    }\n\n    try {\n      const input = JSON.parse(toolCall.input);\n      const toolCalls: ToolCall[] = input.tool_calls || [];\n      const reason: string = input.reason;\n\n      const approved = await approvalHandler(toolCalls, reason);\n      \n      const result = {\n        approved,\n        reason: approved ? 'Approved by user' : 'Denied by user',\n        tool_calls: toolCalls\n      };\n\n      await this.sendToolResponse(toolCall.tool_call_id, result);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      await this.sendToolResponse(toolCall.tool_call_id, {\n        approved: false,\n        reason: `Error processing approval request: ${errorMessage}`,\n        tool_calls: []\n      });\n    }\n  }\n\n  /**\n   * Send tool response back to the agent\n   */\n  private async sendToolResponse(toolCallId: string, result: any): Promise<void> {\n    const responseMessage = DistriClient.initMessage('', 'user');\n    responseMessage.metadata = {\n      type: 'tool_response',\n      tool_call_id: toolCallId,\n      result: typeof result === 'string' ? result : JSON.stringify(result)\n    } as MessageMetadata;\n\n    const params = DistriClient.initMessageParams(responseMessage);\n    await this.client.sendMessage(this.agentDefinition.id, params);\n  }\n\n  /**\n   * Create an agent instance from an agent ID\n   */\n  static async create(agentId: string, client: DistriClient): Promise<Agent> {\n    const agentDefinition = await client.getAgent(agentId);\n    return new Agent(agentDefinition, client);\n  }\n\n  /**\n   * List all available agents\n   */\n  static async list(client: DistriClient): Promise<Agent[]> {\n    const agentDefinitions = await client.getAgents();\n    return agentDefinitions.map(def => new Agent(def, client));\n  }\n}"],"mappings":"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","names":[]}