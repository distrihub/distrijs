{"version":3,"sources":["../src/index.ts","../src/DistriProvider.tsx","../src/useAgents.ts","../src/useTask.ts","../src/useThreads.ts"],"sourcesContent":["// Main exports for @distri/react package\n\nexport { DistriProvider, useDistri, useDistriClient } from './DistriProvider';\nexport { useAgents } from './useAgents';\nexport { useTask } from './useTask';\nexport { useThreads, useThreadMessages } from './useThreads';\n\nexport type { UseAgentsResult } from './useAgents';\nexport type { UseTaskOptions, UseTaskResult } from './useTask';\nexport type { UseThreadsResult, UseThreadMessagesOptions, UseThreadMessagesResult } from './useThreads';\n\n// Re-export types from core for convenience\nexport type {\n  DistriClientConfig,\n  DistriAgent,\n  DistriThread,\n  AgentCard,\n  Task,\n  Message,\n  TaskStatus,\n  MessageSendParams\n} from '@distri/core';","import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\nimport { DistriClient, DistriClientConfig } from '@distri/core';\n\ninterface DistriContextValue {\n  client: DistriClient | null;\n  error: Error | null;\n  isLoading: boolean;\n}\n\nconst DistriContext = createContext<DistriContextValue>({\n  client: null,\n  error: null,\n  isLoading: true\n});\n\ninterface DistriProviderProps {\n  config: DistriClientConfig;\n  children: ReactNode;\n}\n\nexport function DistriProvider({ config, children }: DistriProviderProps) {\n  const [client, setClient] = useState<DistriClient | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    let currentClient: DistriClient | null = null;\n\n    try {\n      console.log('[DistriProvider] Initializing client with config:', config);\n      currentClient = new DistriClient(config);\n      setClient(currentClient);\n      setError(null);\n      setIsLoading(false);\n      console.log('[DistriProvider] Client initialized successfully');\n    } catch (err) {\n      console.error('[DistriProvider] Failed to initialize client:', err);\n      const error = err instanceof Error ? err : new Error('Failed to initialize client');\n      setError(error);\n      setClient(null);\n      setIsLoading(false);\n    }\n\n    // Cleanup function\n    return () => {\n      console.log('[DistriProvider] Cleaning up client');\n      if (currentClient) {\n        currentClient.disconnect();\n      }\n    };\n  }, [config.baseUrl, config.apiVersion, config.debug]); // Only depend on key config values\n\n  const contextValue: DistriContextValue = {\n    client,\n    error,\n    isLoading\n  };\n\n  if (error) {\n    console.error('[DistriProvider] Rendering error state:', error.message);\n  }\n\n  if (isLoading) {\n    console.log('[DistriProvider] Rendering loading state');\n  }\n\n  if (client) {\n    console.log('[DistriProvider] Rendering with client available');\n  }\n\n  return (\n    <DistriContext.Provider value={contextValue}>\n      {children}\n    </DistriContext.Provider>\n  );\n}\n\nexport function useDistri(): DistriContextValue {\n  const context = useContext(DistriContext);\n  if (!context) {\n    throw new Error('useDistri must be used within a DistriProvider');\n  }\n  return context;\n}\n\nexport function useDistriClient(): DistriClient {\n  const { client, error, isLoading } = useDistri();\n  \n  if (isLoading) {\n    throw new Error('Distri client is still loading');\n  }\n  \n  if (error) {\n    throw new Error(`Distri client initialization failed: ${error.message}`);\n  }\n  \n  if (!client) {\n    throw new Error('Distri client is not initialized');\n  }\n  \n  return client;\n}","import { useState, useEffect, useCallback } from 'react';\nimport { DistriAgent } from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseAgentsResult {\n  agents: DistriAgent[];\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n  getAgent: (agentId: string) => Promise<DistriAgent>;\n}\n\nexport function useAgents(): UseAgentsResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [agents, setAgents] = useState<DistriAgent[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchAgents = useCallback(async () => {\n    if (!client) {\n      console.log('[useAgents] Client not available, skipping fetch');\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      console.log('[useAgents] Fetching agents...');\n      const fetchedAgents = await client.getAgents();\n      console.log('[useAgents] Fetched agents:', fetchedAgents);\n      setAgents(fetchedAgents);\n    } catch (err) {\n      console.error('[useAgents] Failed to fetch agents:', err);\n      setError(err instanceof Error ? err : new Error('Failed to fetch agents'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client]);\n\n  const getAgent = useCallback(async (agentId: string): Promise<DistriAgent> => {\n    if (!client) {\n      throw new Error('Client not available');\n    }\n\n    try {\n      const agent = await client.getAgent(agentId);\n      \n      // Update the agent in our local state if it exists\n      setAgents(prev => prev.map(a => a.id === agentId ? agent : a));\n      \n      return agent;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to get agent');\n      setError(error);\n      throw error;\n    }\n  }, [client]);\n\n  useEffect(() => {\n    if (clientLoading) {\n      console.log('[useAgents] Client is loading, waiting...');\n      setLoading(true);\n      return;\n    }\n\n    if (clientError) {\n      console.error('[useAgents] Client error:', clientError);\n      setError(clientError);\n      setLoading(false);\n      return;\n    }\n\n    if (client) {\n      console.log('[useAgents] Client ready, fetching agents');\n      fetchAgents();\n    } else {\n      console.log('[useAgents] No client available');\n      setLoading(false);\n    }\n  }, [clientLoading, clientError, client, fetchAgents]);\n\n  return {\n    agents,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    refetch: fetchAgents,\n    getAgent\n  };\n}","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  Task, \n  Message, \n  MessageSendParams, \n  TaskStatusUpdateEvent,\n  TaskArtifactUpdateEvent,\n  DistriClient\n} from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseTaskOptions {\n  agentId: string;\n  autoSubscribe?: boolean;\n}\n\nexport interface UseTaskResult {\n  task: Task | null;\n  loading: boolean;\n  error: Error | null;\n  messages: Message[];\n  isStreaming: boolean;\n  sendMessage: (text: string, configuration?: MessageSendParams['configuration']) => Promise<void>;\n  sendMessageStream: (text: string, configuration?: MessageSendParams['configuration']) => Promise<void>;\n  getTask: (taskId: string) => Promise<void>;\n  clearTask: () => void;\n  clearMessages: () => void;\n}\n\nexport function useTask({ agentId, autoSubscribe = true }: UseTaskOptions): UseTaskResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [task, setTask] = useState<Task | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const sendMessage = useCallback(async (\n    text: string, \n    configuration?: MessageSendParams['configuration']\n  ) => {\n    if (!client) {\n      setError(new Error('Client not available'));\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const message = DistriClient.createMessage(messageId, text, 'user');\n      \n      // Add user message to local state immediately\n      setMessages(prev => [...prev, message]);\n\n      const params = DistriClient.createMessageParams(message, configuration);\n      const result = await client.sendMessage(agentId, params);\n      \n      if (result.kind === 'task') {\n        setTask(result as Task);\n      } else if (result.kind === 'message') {\n        setMessages(prev => [...prev, result as Message]);\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to send message'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client, agentId]);\n\n  const sendMessageStream = useCallback(async (\n    text: string,\n    configuration?: MessageSendParams['configuration']\n  ) => {\n    if (!client) {\n      setError(new Error('Client not available'));\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      setIsStreaming(true);\n\n      // Cancel any existing stream\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      abortControllerRef.current = new AbortController();\n\n      const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const message = DistriClient.createMessage(messageId, text, 'user');\n      \n      // Add user message to local state immediately\n      setMessages(prev => [...prev, message]);\n\n             const params = DistriClient.createMessageParams(message, {\n         blocking: false,\n         acceptedOutputModes: ['text/plain'],\n         ...configuration\n       });\n\n      const stream = client.sendMessageStream(agentId, params);\n      let currentMessage: Message | null = null;\n\n      for await (const event of stream) {\n        if (abortControllerRef.current?.signal.aborted) {\n          break;\n        }\n\n        if (event.kind === 'task') {\n          setTask(event as Task);\n        } else if (event.kind === 'status-update') {\n          const statusEvent = event as TaskStatusUpdateEvent;\n          if (statusEvent.status.message) {\n            currentMessage = statusEvent.status.message;\n            setMessages(prev => {\n              const existing = prev.find(m => m.messageId === currentMessage!.messageId);\n              if (existing) {\n                return prev.map(m => m.messageId === currentMessage!.messageId ? currentMessage! : m);\n              } else {\n                return [...prev, currentMessage!];\n              }\n            });\n          }\n          \n          if (statusEvent.final) {\n            setIsStreaming(false);\n            break;\n          }\n        } else if (event.kind === 'artifact-update') {\n          const artifactEvent = event as TaskArtifactUpdateEvent;\n          // Handle artifact updates if needed\n          console.log('Artifact update:', artifactEvent);\n        } else if (event.kind === 'message') {\n          const messageEvent = event as Message;\n          setMessages(prev => {\n            const existing = prev.find(m => m.messageId === messageEvent.messageId);\n            if (existing) {\n              return prev.map(m => m.messageId === messageEvent.messageId ? messageEvent : m);\n            } else {\n              return [...prev, messageEvent];\n            }\n          });\n        }\n      }\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        // Stream was cancelled, not an error\n        return;\n      }\n      setError(err instanceof Error ? err : new Error('Failed to stream message'));\n    } finally {\n      setLoading(false);\n      setIsStreaming(false);\n    }\n  }, [client, agentId]);\n\n  const getTask = useCallback(async (taskId: string) => {\n    if (!client) {\n      setError(new Error('Client not available'));\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const fetchedTask = await client.getTask(agentId, taskId);\n      setTask(fetchedTask);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch task'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client, agentId]);\n\n  const clearTask = useCallback(() => {\n    setTask(null);\n    setError(null);\n    setIsStreaming(false);\n    \n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return {\n    task,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    messages,\n    isStreaming,\n    sendMessage,\n    sendMessageStream,\n    getTask,\n    clearTask,\n    clearMessages\n  };\n}","import { useState, useEffect, useCallback } from 'react';\nimport { DistriThread, Message } from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseThreadsResult {\n  threads: DistriThread[];\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n  createThread: (agentId: string, title: string) => DistriThread;\n  deleteThread: (threadId: string) => Promise<void>;\n  updateThread: (threadId: string) => Promise<void>;\n}\n\nexport function useThreads(): UseThreadsResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [threads, setThreads] = useState<DistriThread[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchThreads = useCallback(async () => {\n    if (!client) {\n      console.log('[useThreads] Client not available, skipping fetch');\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      console.log('[useThreads] Fetching threads...');\n      const fetchedThreads = await client.getThreads();\n      console.log('[useThreads] Fetched threads:', fetchedThreads);\n      setThreads(fetchedThreads);\n    } catch (err) {\n      console.error('[useThreads] Failed to fetch threads:', err);\n      setError(err instanceof Error ? err : new Error('Failed to fetch threads'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client]);\n\n  const createThread = useCallback((agentId: string, title: string): DistriThread => {\n    const newThread: DistriThread = {\n      id: `thread-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      title,\n      agent_id: agentId,\n      agent_name: agentId, // Will be updated when we have agent info\n      updated_at: new Date().toISOString(),\n      message_count: 0,\n      last_message: undefined,\n    };\n\n    setThreads(prev => [newThread, ...prev]);\n    return newThread;\n  }, []);\n\n  const deleteThread = useCallback(async (threadId: string) => {\n    if (!client) {\n      throw new Error('Client not available');\n    }\n\n    try {\n             // Try to delete from server (may not exist yet for local threads)\n       const response = await fetch(`${client.baseUrl}/api/v1/threads/${threadId}`, {\n         method: 'DELETE',\n       });\n\n      // Remove from local state regardless of server response\n      setThreads(prev => prev.filter(thread => thread.id !== threadId));\n    } catch (err) {\n      // Still remove from local state even if server delete fails\n      setThreads(prev => prev.filter(thread => thread.id !== threadId));\n      console.warn('Failed to delete thread from server, but removed locally:', err);\n    }\n  }, [client]);\n\n  const updateThread = useCallback(async (threadId: string) => {\n    if (!client) {\n      return;\n    }\n\n         try {\n       const response = await fetch(`${client.baseUrl}/api/v1/threads/${threadId}`);\n       if (response.ok) {\n        const updatedThread = await response.json();\n        setThreads(prev =>\n          prev.map(thread =>\n            thread.id === threadId ? updatedThread : thread\n          )\n        );\n      }\n    } catch (err) {\n      console.warn('Failed to update thread:', err);\n    }\n  }, [client]);\n\n  useEffect(() => {\n    if (clientLoading) {\n      console.log('[useThreads] Client is loading, waiting...');\n      setLoading(true);\n      return;\n    }\n\n    if (clientError) {\n      console.error('[useThreads] Client error:', clientError);\n      setError(clientError);\n      setLoading(false);\n      return;\n    }\n\n    if (client) {\n      console.log('[useThreads] Client ready, fetching threads');\n      fetchThreads();\n    } else {\n      console.log('[useThreads] No client available');\n      setLoading(false);\n    }\n  }, [clientLoading, clientError, client, fetchThreads]);\n\n  return {\n    threads,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    refetch: fetchThreads,\n    createThread,\n    deleteThread,\n    updateThread\n  };\n}\n\nexport interface UseThreadMessagesOptions {\n  threadId: string | null;\n}\n\nexport interface UseThreadMessagesResult {\n  messages: Message[];\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n}\n\nexport function useThreadMessages({ threadId }: UseThreadMessagesOptions): UseThreadMessagesResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchMessages = useCallback(async () => {\n    if (!client || !threadId) {\n      setMessages([]);\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      const fetchedMessages = await client.getThreadMessages(threadId);\n      setMessages(fetchedMessages);\n    } catch (err) {\n      console.error('[useThreadMessages] Failed to fetch messages:', err);\n      setError(err instanceof Error ? err : new Error('Failed to fetch messages'));\n      setMessages([]); // Clear messages on error\n    } finally {\n      setLoading(false);\n    }\n  }, [client, threadId]);\n\n  useEffect(() => {\n    if (!clientLoading && !clientError && threadId) {\n      fetchMessages();\n    } else {\n      setMessages([]);\n    }\n  }, [clientLoading, clientError, threadId, fetchMessages]);\n\n  return {\n    messages,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    refetch: fetchMessages\n  };\n}"],"mappings":"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","names":["error","import_react","error","import_react","import_core","import_react"]}