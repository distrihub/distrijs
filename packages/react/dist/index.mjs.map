{"version":3,"sources":["../src/DistriProvider.tsx","../src/useAgents.ts","../src/useTask.ts"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\nimport { DistriClient, DistriClientConfig } from '@distri/core';\n\ninterface DistriContextValue {\n  client: DistriClient | null;\n  error: Error | null;\n  isLoading: boolean;\n}\n\nconst DistriContext = createContext<DistriContextValue>({\n  client: null,\n  error: null,\n  isLoading: true\n});\n\ninterface DistriProviderProps {\n  config: DistriClientConfig;\n  children: ReactNode;\n}\n\nexport function DistriProvider({ config, children }: DistriProviderProps) {\n  const [client, setClient] = useState<DistriClient | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    let currentClient: DistriClient | null = null;\n\n    try {\n      console.log('[DistriProvider] Initializing client with config:', config);\n      currentClient = new DistriClient(config);\n      setClient(currentClient);\n      setError(null);\n      setIsLoading(false);\n      console.log('[DistriProvider] Client initialized successfully');\n    } catch (err) {\n      console.error('[DistriProvider] Failed to initialize client:', err);\n      const error = err instanceof Error ? err : new Error('Failed to initialize client');\n      setError(error);\n      setClient(null);\n      setIsLoading(false);\n    }\n\n    // Cleanup function\n    return () => {\n      console.log('[DistriProvider] Cleaning up client');\n      if (currentClient) {\n        currentClient.disconnect();\n      }\n    };\n  }, [config.baseUrl, config.apiVersion, config.debug]); // Only depend on key config values\n\n  const contextValue: DistriContextValue = {\n    client,\n    error,\n    isLoading\n  };\n\n  if (error) {\n    console.error('[DistriProvider] Rendering error state:', error.message);\n  }\n\n  if (isLoading) {\n    console.log('[DistriProvider] Rendering loading state');\n  }\n\n  if (client) {\n    console.log('[DistriProvider] Rendering with client available');\n  }\n\n  return (\n    <DistriContext.Provider value={contextValue}>\n      {children}\n    </DistriContext.Provider>\n  );\n}\n\nexport function useDistri(): DistriContextValue {\n  const context = useContext(DistriContext);\n  if (!context) {\n    throw new Error('useDistri must be used within a DistriProvider');\n  }\n  return context;\n}\n\nexport function useDistriClient(): DistriClient {\n  const { client, error, isLoading } = useDistri();\n  \n  if (isLoading) {\n    throw new Error('Distri client is still loading');\n  }\n  \n  if (error) {\n    throw new Error(`Distri client initialization failed: ${error.message}`);\n  }\n  \n  if (!client) {\n    throw new Error('Distri client is not initialized');\n  }\n  \n  return client;\n}","import { useState, useEffect, useCallback } from 'react';\nimport { AgentCard } from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseAgentsResult {\n  agents: AgentCard[];\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n  getAgent: (agentId: string) => Promise<AgentCard>;\n}\n\nexport function useAgents(): UseAgentsResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [agents, setAgents] = useState<AgentCard[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchAgents = useCallback(async () => {\n    if (!client) {\n      console.log('[useAgents] Client not available, skipping fetch');\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      console.log('[useAgents] Fetching agents...');\n      const fetchedAgents = await client.getAgents();\n      console.log('[useAgents] Fetched agents:', fetchedAgents);\n      setAgents(fetchedAgents);\n    } catch (err) {\n      console.error('[useAgents] Failed to fetch agents:', err);\n      setError(err instanceof Error ? err : new Error('Failed to fetch agents'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client]);\n\n  const getAgent = useCallback(async (agentUrl: string): Promise<AgentCard> => {\n    if (!client) {\n      throw new Error('Client not available');\n    }\n\n    try {\n      const agent = await client.getAgent(agentUrl);\n      \n      // Update the agent in our local state if it exists\n      // Since AgentCard doesn't have an id property, we'll use url as the identifier\n      setAgents(prev => prev.map(a => a.url === agentUrl ? agent : a));\n      \n      return agent;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to get agent');\n      setError(error);\n      throw error;\n    }\n  }, [client]);\n\n  useEffect(() => {\n    if (clientLoading) {\n      console.log('[useAgents] Client is loading, waiting...');\n      setLoading(true);\n      return;\n    }\n\n    if (clientError) {\n      console.error('[useAgents] Client error:', clientError);\n      setError(clientError);\n      setLoading(false);\n      return;\n    }\n\n    if (client) {\n      console.log('[useAgents] Client ready, fetching agents');\n      fetchAgents();\n    } else {\n      console.log('[useAgents] No client available');\n      setLoading(false);\n    }\n  }, [clientLoading, clientError, client, fetchAgents]);\n\n  return {\n    agents,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    refetch: fetchAgents,\n    getAgent\n  };\n}","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  Task, \n  Message as A2AMessage, \n  MessageSendParams, \n  CreateTaskRequest,\n  DistriClient,\n  TextDeltaEvent,\n  TaskStatusChangedEvent,\n  TaskCompletedEvent,\n  TaskErrorEvent,\n  TaskStatus\n} from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseTaskOptions {\n  agentId: string;\n  autoSubscribe?: boolean;\n}\n\nexport interface UseTaskResult {\n  task: Task | null;\n  loading: boolean;\n  error: Error | null;\n  streamingText: string;\n  isStreaming: boolean;\n  sendMessage: (text: string, configuration?: MessageSendParams['configuration']) => Promise<void>;\n  createTask: (message: A2AMessage, configuration?: MessageSendParams['configuration']) => Promise<void>;\n  getTask: (taskId: string) => Promise<void>;\n  clearTask: () => void;\n}\n\nexport function useTask({ agentId, autoSubscribe = true }: UseTaskOptions): UseTaskResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [task, setTask] = useState<Task | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [streamingText, setStreamingText] = useState('');\n  const [isStreaming, setIsStreaming] = useState(false);\n  const eventSourceRef = useRef<EventSource | null>(null);\n\n  const createTask = useCallback(async (\n    message: A2AMessage, \n    configuration?: MessageSendParams['configuration']\n  ) => {\n    if (!client) {\n      setError(new Error('Client not available'));\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      setStreamingText('');\n      setIsStreaming(true);\n\n      const request: CreateTaskRequest = {\n        agentId,\n        message,\n        configuration\n      };\n\n      const response = await client.createTask(request);\n      \n      // Get the full task details\n      const fullTask = await client.getTask(response.taskId);\n      setTask(fullTask);\n      \n      if (autoSubscribe) {\n        subscribeToAgent();\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to create task'));\n      setIsStreaming(false);\n    } finally {\n      setLoading(false);\n    }\n  }, [client, agentId, autoSubscribe]);\n\n  const sendMessage = useCallback(async (\n    text: string,\n    configuration?: MessageSendParams['configuration']\n  ) => {\n    const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const message = DistriClient.createMessage(messageId, text, 'user');\n    \n    await createTask(message, configuration);\n  }, [createTask]);\n\n  const getTask = useCallback(async (taskId: string) => {\n    if (!client) {\n      setError(new Error('Client not available'));\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const fetchedTask = await client.getTask(taskId);\n      setTask(fetchedTask);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch task'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client]);\n\n  const clearTask = useCallback(() => {\n    setTask(null);\n    setStreamingText('');\n    setIsStreaming(false);\n    setError(null);\n    \n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n      eventSourceRef.current = null;\n    }\n  }, []);\n\n  const subscribeToAgent = useCallback(() => {\n    if (!client || eventSourceRef.current) {\n      return; // No client or already subscribed\n    }\n\n    try {\n      const eventSource = client.subscribeToAgent(agentId);\n      eventSourceRef.current = eventSource;\n\n      const handleTextDelta = (event: TextDeltaEvent) => {\n        if (task && event.task_id === task.id) {\n          setStreamingText(prev => prev + event.delta);\n        }\n      };\n\n      const handleTaskStatusChanged = (event: TaskStatusChangedEvent) => {\n        if (task && event.task_id === task.id) {\n          // Create a proper TaskStatus object\n          const newStatus: TaskStatus = {\n            state: event.status as any, // Type assertion for the status\n            timestamp: new Date().toISOString()\n          };\n          setTask(prev => prev ? { ...prev, status: newStatus } : null);\n          \n          if (event.status === 'completed' || event.status === 'failed' || event.status === 'canceled') {\n            setIsStreaming(false);\n          }\n        }\n      };\n\n      const handleTaskCompleted = (event: TaskCompletedEvent) => {\n        if (task && event.task_id === task.id) {\n          setIsStreaming(false);\n          // Optionally refresh the full task to get the complete result\n          getTask(event.task_id);\n        }\n      };\n\n      const handleTaskError = (event: TaskErrorEvent) => {\n        if (task && event.task_id === task.id) {\n          setError(new Error(event.error));\n          setIsStreaming(false);\n        }\n      };\n\n      // Subscribe to events\n      client.on('text_delta', handleTextDelta);\n      client.on('task_status_changed', handleTaskStatusChanged);\n      client.on('task_completed', handleTaskCompleted);\n      client.on('task_error', handleTaskError);\n\n      // Store cleanup function\n      const cleanup = () => {\n        client.off('text_delta', handleTextDelta);\n        client.off('task_status_changed', handleTaskStatusChanged);\n        client.off('task_completed', handleTaskCompleted);\n        client.off('task_error', handleTaskError);\n      };\n\n      return cleanup;\n    } catch (err) {\n      console.warn('Failed to subscribe to agent events:', err);\n    }\n  }, [client, agentId, task, getTask]);\n\n  // Auto-subscribe when agent changes and client is available\n  useEffect(() => {\n    if (autoSubscribe && agentId && client && !clientLoading) {\n      const cleanup = subscribeToAgent();\n      return cleanup;\n    }\n  }, [autoSubscribe, agentId, client, clientLoading, subscribeToAgent]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n    };\n  }, []);\n\n  return {\n    task,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    streamingText,\n    isStreaming,\n    sendMessage,\n    createTask,\n    getTask,\n    clearTask\n  };\n}"],"mappings":";AAAA,SAAgB,eAAe,YAAY,WAAW,gBAA2B;AACjF,SAAS,oBAAwC;AAsE7C;AA9DJ,IAAM,gBAAgB,cAAkC;AAAA,EACtD,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,WAAW;AACb,CAAC;AAOM,SAAS,eAAe,EAAE,QAAQ,SAAS,GAAwB;AACxE,QAAM,CAAC,QAAQ,SAAS,IAAI,SAA8B,IAAI;AAC9D,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAuB,IAAI;AACrD,QAAM,CAAC,WAAW,YAAY,IAAI,SAAS,IAAI;AAE/C,YAAU,MAAM;AACd,QAAI,gBAAqC;AAEzC,QAAI;AACF,cAAQ,IAAI,qDAAqD,MAAM;AACvE,sBAAgB,IAAI,aAAa,MAAM;AACvC,gBAAU,aAAa;AACvB,eAAS,IAAI;AACb,mBAAa,KAAK;AAClB,cAAQ,IAAI,kDAAkD;AAAA,IAChE,SAAS,KAAK;AACZ,cAAQ,MAAM,iDAAiD,GAAG;AAClE,YAAMA,SAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,6BAA6B;AAClF,eAASA,MAAK;AACd,gBAAU,IAAI;AACd,mBAAa,KAAK;AAAA,IACpB;AAGA,WAAO,MAAM;AACX,cAAQ,IAAI,qCAAqC;AACjD,UAAI,eAAe;AACjB,sBAAc,WAAW;AAAA,MAC3B;AAAA,IACF;AAAA,EACF,GAAG,CAAC,OAAO,SAAS,OAAO,YAAY,OAAO,KAAK,CAAC;AAEpD,QAAM,eAAmC;AAAA,IACvC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,OAAO;AACT,YAAQ,MAAM,2CAA2C,MAAM,OAAO;AAAA,EACxE;AAEA,MAAI,WAAW;AACb,YAAQ,IAAI,0CAA0C;AAAA,EACxD;AAEA,MAAI,QAAQ;AACV,YAAQ,IAAI,kDAAkD;AAAA,EAChE;AAEA,SACE,oBAAC,cAAc,UAAd,EAAuB,OAAO,cAC5B,UACH;AAEJ;AAEO,SAAS,YAAgC;AAC9C,QAAM,UAAU,WAAW,aAAa;AACxC,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AACA,SAAO;AACT;AAEO,SAAS,kBAAgC;AAC9C,QAAM,EAAE,QAAQ,OAAO,UAAU,IAAI,UAAU;AAE/C,MAAI,WAAW;AACb,UAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AAEA,MAAI,OAAO;AACT,UAAM,IAAI,MAAM,wCAAwC,MAAM,OAAO,EAAE;AAAA,EACzE;AAEA,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACpD;AAEA,SAAO;AACT;;;ACrGA,SAAS,YAAAC,WAAU,aAAAC,YAAW,mBAAmB;AAY1C,SAAS,YAA6B;AAC3C,QAAM,EAAE,QAAQ,OAAO,aAAa,WAAW,cAAc,IAAI,UAAU;AAC3E,QAAM,CAAC,QAAQ,SAAS,IAAIC,UAAsB,CAAC,CAAC;AACpD,QAAM,CAAC,SAAS,UAAU,IAAIA,UAAS,IAAI;AAC3C,QAAM,CAAC,OAAO,QAAQ,IAAIA,UAAuB,IAAI;AAErD,QAAM,cAAc,YAAY,YAAY;AAC1C,QAAI,CAAC,QAAQ;AACX,cAAQ,IAAI,kDAAkD;AAC9D;AAAA,IACF;AAEA,QAAI;AACF,iBAAW,IAAI;AACf,eAAS,IAAI;AACb,cAAQ,IAAI,gCAAgC;AAC5C,YAAM,gBAAgB,MAAM,OAAO,UAAU;AAC7C,cAAQ,IAAI,+BAA+B,aAAa;AACxD,gBAAU,aAAa;AAAA,IACzB,SAAS,KAAK;AACZ,cAAQ,MAAM,uCAAuC,GAAG;AACxD,eAAS,eAAe,QAAQ,MAAM,IAAI,MAAM,wBAAwB,CAAC;AAAA,IAC3E,UAAE;AACA,iBAAW,KAAK;AAAA,IAClB;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAEX,QAAM,WAAW,YAAY,OAAO,aAAyC;AAC3E,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACxC;AAEA,QAAI;AACF,YAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;AAI5C,gBAAU,UAAQ,KAAK,IAAI,OAAK,EAAE,QAAQ,WAAW,QAAQ,CAAC,CAAC;AAE/D,aAAO;AAAA,IACT,SAAS,KAAK;AACZ,YAAMC,SAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,qBAAqB;AAC1E,eAASA,MAAK;AACd,YAAMA;AAAA,IACR;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAEX,EAAAC,WAAU,MAAM;AACd,QAAI,eAAe;AACjB,cAAQ,IAAI,2CAA2C;AACvD,iBAAW,IAAI;AACf;AAAA,IACF;AAEA,QAAI,aAAa;AACf,cAAQ,MAAM,6BAA6B,WAAW;AACtD,eAAS,WAAW;AACpB,iBAAW,KAAK;AAChB;AAAA,IACF;AAEA,QAAI,QAAQ;AACV,cAAQ,IAAI,2CAA2C;AACvD,kBAAY;AAAA,IACd,OAAO;AACL,cAAQ,IAAI,iCAAiC;AAC7C,iBAAW,KAAK;AAAA,IAClB;AAAA,EACF,GAAG,CAAC,eAAe,aAAa,QAAQ,WAAW,CAAC;AAEpD,SAAO;AAAA,IACL;AAAA,IACA,SAAS,WAAW;AAAA,IACpB,OAAO,SAAS;AAAA,IAChB,SAAS;AAAA,IACT;AAAA,EACF;AACF;;;ACzFA,SAAS,YAAAC,WAAU,aAAAC,YAAW,eAAAC,cAAa,cAAc;AACzD;AAAA,EAKE,gBAAAC;AAAA,OAMK;AAoBA,SAAS,QAAQ,EAAE,SAAS,gBAAgB,KAAK,GAAkC;AACxF,QAAM,EAAE,QAAQ,OAAO,aAAa,WAAW,cAAc,IAAI,UAAU;AAC3E,QAAM,CAAC,MAAM,OAAO,IAAIC,UAAsB,IAAI;AAClD,QAAM,CAAC,SAAS,UAAU,IAAIA,UAAS,KAAK;AAC5C,QAAM,CAAC,OAAO,QAAQ,IAAIA,UAAuB,IAAI;AACrD,QAAM,CAAC,eAAe,gBAAgB,IAAIA,UAAS,EAAE;AACrD,QAAM,CAAC,aAAa,cAAc,IAAIA,UAAS,KAAK;AACpD,QAAM,iBAAiB,OAA2B,IAAI;AAEtD,QAAM,aAAaC,aAAY,OAC7B,SACA,kBACG;AACH,QAAI,CAAC,QAAQ;AACX,eAAS,IAAI,MAAM,sBAAsB,CAAC;AAC1C;AAAA,IACF;AAEA,QAAI;AACF,iBAAW,IAAI;AACf,eAAS,IAAI;AACb,uBAAiB,EAAE;AACnB,qBAAe,IAAI;AAEnB,YAAM,UAA6B;AAAA,QACjC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,YAAM,WAAW,MAAM,OAAO,WAAW,OAAO;AAGhD,YAAM,WAAW,MAAM,OAAO,QAAQ,SAAS,MAAM;AACrD,cAAQ,QAAQ;AAEhB,UAAI,eAAe;AACjB,yBAAiB;AAAA,MACnB;AAAA,IACF,SAAS,KAAK;AACZ,eAAS,eAAe,QAAQ,MAAM,IAAI,MAAM,uBAAuB,CAAC;AACxE,qBAAe,KAAK;AAAA,IACtB,UAAE;AACA,iBAAW,KAAK;AAAA,IAClB;AAAA,EACF,GAAG,CAAC,QAAQ,SAAS,aAAa,CAAC;AAEnC,QAAM,cAAcA,aAAY,OAC9B,MACA,kBACG;AACH,UAAM,YAAY,OAAO,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAC9E,UAAM,UAAUC,cAAa,cAAc,WAAW,MAAM,MAAM;AAElE,UAAM,WAAW,SAAS,aAAa;AAAA,EACzC,GAAG,CAAC,UAAU,CAAC;AAEf,QAAM,UAAUD,aAAY,OAAO,WAAmB;AACpD,QAAI,CAAC,QAAQ;AACX,eAAS,IAAI,MAAM,sBAAsB,CAAC;AAC1C;AAAA,IACF;AAEA,QAAI;AACF,iBAAW,IAAI;AACf,eAAS,IAAI;AAEb,YAAM,cAAc,MAAM,OAAO,QAAQ,MAAM;AAC/C,cAAQ,WAAW;AAAA,IACrB,SAAS,KAAK;AACZ,eAAS,eAAe,QAAQ,MAAM,IAAI,MAAM,sBAAsB,CAAC;AAAA,IACzE,UAAE;AACA,iBAAW,KAAK;AAAA,IAClB;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAEX,QAAM,YAAYA,aAAY,MAAM;AAClC,YAAQ,IAAI;AACZ,qBAAiB,EAAE;AACnB,mBAAe,KAAK;AACpB,aAAS,IAAI;AAEb,QAAI,eAAe,SAAS;AAC1B,qBAAe,QAAQ,MAAM;AAC7B,qBAAe,UAAU;AAAA,IAC3B;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,mBAAmBA,aAAY,MAAM;AACzC,QAAI,CAAC,UAAU,eAAe,SAAS;AACrC;AAAA,IACF;AAEA,QAAI;AACF,YAAM,cAAc,OAAO,iBAAiB,OAAO;AACnD,qBAAe,UAAU;AAEzB,YAAM,kBAAkB,CAAC,UAA0B;AACjD,YAAI,QAAQ,MAAM,YAAY,KAAK,IAAI;AACrC,2BAAiB,UAAQ,OAAO,MAAM,KAAK;AAAA,QAC7C;AAAA,MACF;AAEA,YAAM,0BAA0B,CAAC,UAAkC;AACjE,YAAI,QAAQ,MAAM,YAAY,KAAK,IAAI;AAErC,gBAAM,YAAwB;AAAA,YAC5B,OAAO,MAAM;AAAA;AAAA,YACb,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACpC;AACA,kBAAQ,UAAQ,OAAO,EAAE,GAAG,MAAM,QAAQ,UAAU,IAAI,IAAI;AAE5D,cAAI,MAAM,WAAW,eAAe,MAAM,WAAW,YAAY,MAAM,WAAW,YAAY;AAC5F,2BAAe,KAAK;AAAA,UACtB;AAAA,QACF;AAAA,MACF;AAEA,YAAM,sBAAsB,CAAC,UAA8B;AACzD,YAAI,QAAQ,MAAM,YAAY,KAAK,IAAI;AACrC,yBAAe,KAAK;AAEpB,kBAAQ,MAAM,OAAO;AAAA,QACvB;AAAA,MACF;AAEA,YAAM,kBAAkB,CAAC,UAA0B;AACjD,YAAI,QAAQ,MAAM,YAAY,KAAK,IAAI;AACrC,mBAAS,IAAI,MAAM,MAAM,KAAK,CAAC;AAC/B,yBAAe,KAAK;AAAA,QACtB;AAAA,MACF;AAGA,aAAO,GAAG,cAAc,eAAe;AACvC,aAAO,GAAG,uBAAuB,uBAAuB;AACxD,aAAO,GAAG,kBAAkB,mBAAmB;AAC/C,aAAO,GAAG,cAAc,eAAe;AAGvC,YAAM,UAAU,MAAM;AACpB,eAAO,IAAI,cAAc,eAAe;AACxC,eAAO,IAAI,uBAAuB,uBAAuB;AACzD,eAAO,IAAI,kBAAkB,mBAAmB;AAChD,eAAO,IAAI,cAAc,eAAe;AAAA,MAC1C;AAEA,aAAO;AAAA,IACT,SAAS,KAAK;AACZ,cAAQ,KAAK,wCAAwC,GAAG;AAAA,IAC1D;AAAA,EACF,GAAG,CAAC,QAAQ,SAAS,MAAM,OAAO,CAAC;AAGnC,EAAAE,WAAU,MAAM;AACd,QAAI,iBAAiB,WAAW,UAAU,CAAC,eAAe;AACxD,YAAM,UAAU,iBAAiB;AACjC,aAAO;AAAA,IACT;AAAA,EACF,GAAG,CAAC,eAAe,SAAS,QAAQ,eAAe,gBAAgB,CAAC;AAGpE,EAAAA,WAAU,MAAM;AACd,WAAO,MAAM;AACX,UAAI,eAAe,SAAS;AAC1B,uBAAe,QAAQ,MAAM;AAAA,MAC/B;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,SAAO;AAAA,IACL;AAAA,IACA,SAAS,WAAW;AAAA,IACpB,OAAO,SAAS;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;","names":["error","useState","useEffect","useState","error","useEffect","useState","useEffect","useCallback","DistriClient","useState","useCallback","DistriClient","useEffect"]}