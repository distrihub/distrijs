{"version":3,"sources":["../src/DistriProvider.tsx","../src/useAgents.ts","../src/useChat.ts","../src/useThreads.ts","../src/useAgent.ts","../src/index.ts"],"sourcesContent":["import { createContext, useContext, useEffect, useState, ReactNode } from 'react';\nimport { DistriClient, DistriClientConfig } from '@distri/core';\n\ninterface DistriContextValue {\n  client: DistriClient | null;\n  error: Error | null;\n  isLoading: boolean;\n}\n\nconst DistriContext = createContext<DistriContextValue>({\n  client: null,\n  error: null,\n  isLoading: true\n});\n\ninterface DistriProviderProps {\n  config: DistriClientConfig;\n  children: ReactNode;\n}\n\nconst debug = (config: DistriClientConfig, ...args: any[]): void => {\n  if (config.debug) {\n    console.log('[DistriProvider]', ...args);\n  }\n}\n\n\nexport function DistriProvider({ config, children }: DistriProviderProps) {\n  const [client, setClient] = useState<DistriClient | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    let currentClient: DistriClient | null = null;\n\n    try {\n      debug(config, '[DistriProvider] Initializing client with config:', config);\n      currentClient = new DistriClient(config);\n      setClient(currentClient);\n      setError(null);\n      setIsLoading(false);\n      debug(config, '[DistriProvider] Client initialized successfully');\n    } catch (err) {\n      debug(config, '[DistriProvider] Failed to initialize client:', err);\n      const error = err instanceof Error ? err : new Error('Failed to initialize client');\n      setError(error);\n      setClient(null);\n      setIsLoading(false);\n    }\n\n  }, [config]); // Depend on the entire config object since we memoize it now\n\n  const contextValue: DistriContextValue = {\n    client,\n    error,\n    isLoading\n  };\n\n  if (error) {\n    console.error(config, '[DistriProvider] Rendering error state:', error.message);\n  }\n\n  if (isLoading) {\n    debug(config, '[DistriProvider] Rendering loading state');\n  }\n\n  if (client) {\n    debug(config, '[DistriProvider] Rendering with client available');\n  }\n\n  return (\n    <DistriContext.Provider value={contextValue}>\n      {children}\n    </DistriContext.Provider>\n  );\n}\n\nexport function useDistri(): DistriContextValue {\n  const context = useContext(DistriContext);\n  if (!context) {\n    throw new Error('useDistri must be used within a DistriProvider');\n  }\n  return context;\n}\n\nexport function useDistriClient(): DistriClient {\n  const { client, error, isLoading } = useDistri();\n\n  if (isLoading) {\n    throw new Error('Distri client is still loading');\n  }\n\n  if (error) {\n    throw new Error(`Distri client initialization failed: ${error.message}`);\n  }\n\n  if (!client) {\n    throw new Error('Distri client is not initialized');\n  }\n\n  return client;\n}","import { useState, useEffect, useCallback } from 'react';\nimport { DistriAgent } from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseAgentsResult {\n  agents: DistriAgent[];\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n  getAgent: (agentId: string) => Promise<DistriAgent>;\n}\n\nexport function useAgents(): UseAgentsResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [agents, setAgents] = useState<DistriAgent[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchAgents = useCallback(async () => {\n    if (!client) {\n      console.log('[useAgents] Client not available, skipping fetch');\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      console.log('[useAgents] Fetching agents...');\n      const fetchedAgents = await client.getAgents();\n      console.log('[useAgents] Fetched agents:', fetchedAgents);\n      setAgents(fetchedAgents);\n    } catch (err) {\n      console.error('[useAgents] Failed to fetch agents:', err);\n      setError(err instanceof Error ? err : new Error('Failed to fetch agents'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client]);\n\n  const getAgent = useCallback(async (agentId: string): Promise<DistriAgent> => {\n    if (!client) {\n      throw new Error('Client not available');\n    }\n\n    try {\n      const agent = await client.getAgent(agentId);\n      \n      // Update the agent in our local state if it exists\n      setAgents(prev => prev.map(a => a.id === agentId ? agent : a));\n      \n      return agent;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to get agent');\n      setError(error);\n      throw error;\n    }\n  }, [client]);\n\n  useEffect(() => {\n    if (clientLoading) {\n      console.log('[useAgents] Client is loading, waiting...');\n      setLoading(true);\n      return;\n    }\n\n    if (clientError) {\n      console.error('[useAgents] Client error:', clientError);\n      setError(clientError);\n      setLoading(false);\n      return;\n    }\n\n    if (client) {\n      console.log('[useAgents] Client ready, fetching agents');\n      fetchAgents();\n    } else {\n      console.log('[useAgents] No client available');\n      setLoading(false);\n    }\n  }, [clientLoading, clientError, client, fetchAgents]);\n\n  return {\n    agents,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    refetch: fetchAgents,\n    getAgent\n  };\n}","import { useState, useEffect, useCallback, useRef } from 'react';\nimport {\n  Message,\n  MessageSendParams,\n} from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseChatOptions {\n  agentId: string;\n  contextId?: string;\n}\n\nexport interface UseChatResult {\n  loading: boolean;\n  error: Error | null;\n  messages: Message[];\n  isStreaming: boolean;\n  sendMessage: (params: MessageSendParams) => Promise<void>;\n  sendMessageStream: (params: MessageSendParams) => Promise<void>;\n  clearMessages: () => void;\n  refreshMessages: () => Promise<void>;\n  abort: () => void;\n}\n\nexport function useChat({ agentId, contextId }: UseChatOptions): UseChatResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const fetchMessages = useCallback(async () => {\n    if (!client || !contextId) {\n      setMessages([]);\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      const fetchedMessages = await client.getThreadMessages(contextId);\n      setMessages(fetchedMessages);\n    } catch (err) {\n      console.error('[useThreadMessages] Failed to fetch messages:', err);\n      setError(err instanceof Error ? err : new Error('Failed to fetch messages'));\n      setMessages([]); // Clear messages on error\n    } finally {\n      setLoading(false);\n    }\n  }, [client, contextId]);\n\n  // Load messages when conditions change, but don't include fetchMessages in dependencies\n  useEffect(() => {\n    if (!clientLoading && !clientError && contextId && client) {\n      fetchMessages();\n    } else {\n      setMessages([]);\n    }\n    // Don't include fetchMessages in dependencies to avoid infinite loop\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [clientLoading, clientError, contextId, client]);\n\n  const sendMessage = useCallback(async (\n    params: MessageSendParams,\n  ) => {\n    if (!client) {\n      setError(new Error('Client not available'));\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      // const userMessage = DistriClient.initMessage(input, 'user', contextId);\n      // Add user message to local state immediately\n      setMessages(prev => [...prev, params.message]);\n\n      const result = await client.sendMessage(agentId, params);\n\n      let message = undefined;\n      if (result.kind === 'message') {\n        message = (result as Message);\n      } else if (result.kind === 'task') {\n        message = result.status.message as Message;\n      }\n\n      if (!message) {\n        throw new Error('Invalid response format');\n      }\n\n      setMessages((prev: Message[]) => {\n        if (prev.find(msg => msg.messageId === message.messageId)) {\n          return prev.map(msg => {\n            if (msg.messageId === message.messageId) {\n              return {\n                ...msg,\n                parts: [...msg.parts, ...message.parts],\n              };\n            }\n            return msg;\n          });\n        } else {\n          return [...prev, message];\n        }\n      });\n    } catch (err) {\n      console.error(err);\n      setError(err instanceof Error ? err : new Error('Failed to send message'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client, agentId]);\n\n  const sendMessageStream = useCallback(async (\n    params: MessageSendParams,\n  ) => {\n    if (!client) {\n      setError(new Error('Client not available'));\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      setIsStreaming(true);\n\n      // Cancel any existing stream\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      abortControllerRef.current = new AbortController();\n\n      // const userMessage = DistriClient.initMessage(input, 'user', contextId);\n      // Add user message to local state immediately\n      setMessages(prev => [...prev, params.message]);\n\n      // const params = DistriClient.initMessageParams(userMessage, {\n      //   blocking: false,\n      //   acceptedOutputModes: ['text/plain'],\n      //   ...configuration\n      // });\n\n      setIsStreaming(true);\n\n      const stream = await client.sendMessageStream(agentId, params);\n\n      for await (const event of stream) {\n\n        if (abortControllerRef.current?.signal.aborted) {\n          console.log('abort signal received');\n          break;\n        }\n\n        let message = undefined;\n        if (event.kind === 'message') {\n          message = (event as Message);\n        }\n\n        if (!message) continue;\n        setMessages((prev: Message[]) => {\n          if (prev.find(msg => msg.messageId === message.messageId)) {\n            return prev.map(msg => {\n              if (msg.messageId === message.messageId) {\n                return {\n                  ...msg,\n                  parts: [...msg.parts, ...message.parts],\n                };\n              }\n              return msg;\n            });\n          } else {\n            return [...prev, message];\n          }\n        });\n      }\n      setIsStreaming(false);\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        // Stream was cancelled, not an error\n        return;\n      }\n      console.log('error', err);\n\n      setError(err instanceof Error ? err : new Error('Failed to stream message'));\n    } finally {\n      setLoading(false);\n      setIsStreaming(false);\n    }\n  }, [client, agentId]);\n\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  const abort = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n  }, []);\n\n  return {\n    loading: loading || clientLoading,\n    error: error || clientError,\n    messages,\n    isStreaming,\n    sendMessage,\n    sendMessageStream,\n    clearMessages,\n    refreshMessages: fetchMessages,\n    abort,\n  };\n}","import { useState, useEffect, useCallback } from 'react';\nimport { DistriThread } from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseThreadsResult {\n  threads: DistriThread[];\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n  deleteThread: (threadId: string) => Promise<void>;\n  fetchThread: (threadId: string) => Promise<DistriThread>;\n  updateThread: (threadId: string, localId?: string) => Promise<void>;\n}\n\nexport function useThreads(): UseThreadsResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [threads, setThreads] = useState<DistriThread[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchThreads = useCallback(async () => {\n    if (!client) {\n      console.log('[useThreads] Client not available, skipping fetch');\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      console.log('[useThreads] Fetching threads...');\n      const fetchedThreads = await client.getThreads();\n      console.log('[useThreads] Fetched threads:', fetchedThreads);\n      setThreads(fetchedThreads);\n    } catch (err) {\n      console.error('[useThreads] Failed to fetch threads:', err);\n      setError(err instanceof Error ? err : new Error('Failed to fetch threads'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client]);\n\n  const fetchThread = useCallback(async (threadId: string) => {\n    if (!client) {\n      throw new Error('Client not available');\n    }\n    try {\n      const response = await client.getThread(threadId);\n      return response;\n    } catch (err) {\n      console.error('[useThreads] Failed to fetch thread:', err);\n      throw err;\n    }\n  }, [client]);\n\n  const deleteThread = useCallback(async (threadId: string) => {\n    if (!client) {\n      throw new Error('Client not available');\n    }\n\n    try {\n      // Try to delete from server (may not exist yet for local threads)\n      const response = await fetch(`${client.baseUrl}/api/v1/threads/${threadId}`, {\n        method: 'DELETE',\n      });\n      if (!response.ok) {\n        throw new Error('Failed to delete thread');\n      }\n\n      // Remove from local state regardless of server response\n      setThreads(prev => prev.filter(thread => thread.id !== threadId));\n    } catch (err) {\n      // Still remove from local state even if server delete fails\n      setThreads(prev => prev.filter(thread => thread.id !== threadId));\n      console.warn('Failed to delete thread from server, but removed locally:', err);\n    }\n  }, [client]);\n\n  const updateThread = useCallback(async (threadId: string, localId?: string) => {\n    if (!client) {\n      return;\n    }\n\n    try {\n      const response = await fetch(`${client.baseUrl}/api/v1/threads/${threadId}`);\n      if (response.ok) {\n        const updatedThread = await response.json();\n        setThreads(prev => {\n          // If a local thread with localId exists, replace it with the backend thread\n          if (localId && prev.some(thread => thread.id === localId)) {\n            return [\n              updatedThread,\n              ...prev.filter(thread => thread.id !== localId && thread.id !== threadId)\n            ];\n          }\n          // Otherwise, just update by threadId\n          return prev.map(thread =>\n            thread.id === threadId ? updatedThread : thread\n          );\n        });\n      }\n    } catch (err) {\n      console.warn('Failed to update thread:', err);\n    }\n  }, [client]);\n\n  useEffect(() => {\n    if (clientLoading) {\n      console.log('[useThreads] Client is loading, waiting...');\n      setLoading(true);\n      return;\n    }\n\n    if (clientError) {\n      console.error('[useThreads] Client error:', clientError);\n      setError(clientError);\n      setLoading(false);\n      return;\n    }\n\n    if (client) {\n      console.log('[useThreads] Client ready, fetching threads');\n      fetchThreads();\n    } else {\n      console.log('[useThreads] No client available');\n      setLoading(false);\n    }\n  }, [clientLoading, clientError, client, fetchThreads]);\n\n  return {\n    threads,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    refetch: fetchThreads,\n    deleteThread,\n    fetchThread,\n    updateThread\n  };\n}\n\nexport interface UseThreadMessagesOptions {\n  threadId: string | null;\n}","import React, { useState, useCallback, useRef } from 'react';\nimport {\n  Agent,\n  InvokeConfig,\n  InvokeResult,\n  InvokeStreamResult,\n  ExternalToolHandler,\n  ApprovalHandler,\n  ToolCall,\n} from '@distri/core';\nimport { useDistri } from './DistriProvider';\n\nexport interface UseAgentOptions {\n  agentId: string;\n  autoCreateAgent?: boolean;\n  defaultExternalToolHandlers?: Record<string, ExternalToolHandler>;\n  defaultApprovalHandler?: ApprovalHandler;\n}\n\nexport interface UseAgentResult {\n  agent: Agent | null;\n  loading: boolean;\n  error: Error | null;\n  invoke: (input: string, config?: InvokeConfig) => Promise<InvokeResult | InvokeStreamResult>;\n  invokeWithHandlers: (\n    input: string,\n    handlers?: Record<string, ExternalToolHandler>,\n    approvalHandler?: ApprovalHandler,\n    config?: Omit<InvokeConfig, 'externalToolHandlers' | 'approvalHandler'>\n  ) => Promise<InvokeResult>;\n}\n\n/**\n * React hook for working with a specific agent\n */\nexport function useAgent({\n  agentId,\n  autoCreateAgent = true,\n  defaultExternalToolHandlers,\n  defaultApprovalHandler\n}: UseAgentOptions): UseAgentResult {\n  const { client, error: clientError, isLoading: clientLoading } = useDistri();\n  const [agent, setAgent] = useState<Agent | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const agentRef = useRef<Agent | null>(null);\n\n  // Initialize agent\n  const initializeAgent = useCallback(async () => {\n    if (!client || !agentId || agentRef.current) return;\n\n    try {\n      setLoading(true);\n      setError(null);\n      const newAgent = await Agent.create(agentId, client);\n      agentRef.current = newAgent;\n      setAgent(newAgent);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to create agent'));\n    } finally {\n      setLoading(false);\n    }\n  }, [client, agentId]);\n\n  // Auto-initialize agent when client is ready\n  React.useEffect(() => {\n    if (!clientLoading && !clientError && autoCreateAgent && client) {\n      initializeAgent();\n    }\n  }, [clientLoading, clientError, autoCreateAgent, client, initializeAgent]);\n\n  // Invoke method\n  const invoke = useCallback(async (\n    input: string,\n    config: InvokeConfig = {}\n  ): Promise<InvokeResult | InvokeStreamResult> => {\n    if (!agent) {\n      throw new Error('Agent not initialized');\n    }\n\n    const finalConfig = {\n      ...config,\n      externalToolHandlers: config.externalToolHandlers || defaultExternalToolHandlers,\n      approvalHandler: config.approvalHandler || defaultApprovalHandler\n    };\n\n    return agent.invoke(input, finalConfig);\n  }, [agent, defaultExternalToolHandlers, defaultApprovalHandler]);\n\n  // Convenience method with explicit handlers\n  const invokeWithHandlers = useCallback(async (\n    input: string,\n    handlers?: Record<string, ExternalToolHandler>,\n    approvalHandler?: ApprovalHandler,\n    config: Omit<InvokeConfig, 'externalToolHandlers' | 'approvalHandler'> = {}\n  ): Promise<InvokeResult> => {\n    if (!agent) {\n      throw new Error('Agent not initialized');\n    }\n\n    const result = await agent.invoke(input, {\n      ...config,\n      stream: false,\n      externalToolHandlers: handlers || defaultExternalToolHandlers,\n      approvalHandler: approvalHandler || defaultApprovalHandler\n    });\n\n    // Since stream is false, this will always be InvokeResult\n    return result as InvokeResult;\n  }, [agent, defaultExternalToolHandlers, defaultApprovalHandler]);\n\n  return {\n    agent,\n    loading: loading || clientLoading,\n    error: error || clientError,\n    invoke,\n    invokeWithHandlers\n  };\n}\n\n/**\n * Built-in external tool handlers\n */\nexport const createBuiltinToolHandlers = (): Record<string, ExternalToolHandler> => ({\n  // File upload handler\n  file_upload: async (toolCall: ToolCall) => {\n    const input = JSON.parse(toolCall.input);\n    // This would typically open a file picker\n    // For now, return a placeholder\n    console.log('File upload requested:', input);\n    return { success: true, message: 'File upload simulated' };\n  },\n\n  // Input request handler\n  input_request: async (toolCall: ToolCall) => {\n    const input = JSON.parse(toolCall.input);\n    const userInput = prompt(input.prompt || 'Please provide input:');\n    return { input: userInput };\n  },\n\n  // Email send handler\n  email_send: async (toolCall: ToolCall) => {\n    const input = JSON.parse(toolCall.input);\n    console.log('Email send requested:', input);\n    return { success: true, message: 'Email sent successfully' };\n  }\n});\n\n/**\n * Built-in approval handler with confirm dialog\n */\nexport const createBuiltinApprovalHandler = (): ApprovalHandler => {\n  return async (toolCalls: ToolCall[], reason?: string): Promise<boolean> => {\n    const toolNames = toolCalls.map(tc => tc.tool_name).join(', ');\n    const message = reason\n      ? `${reason}\\n\\nTools to execute: ${toolNames}\\n\\nDo you approve?`\n      : `Execute tools: ${toolNames}?`;\n\n    return confirm(message);\n  };\n};","// Main exports for @distri/react package\n\nexport { DistriProvider, useDistri, useDistriClient } from './DistriProvider';\nexport { useAgents } from './useAgents';\nexport { useChat } from './useChat';\nexport { useThreads } from './useThreads';\nexport { useAgent, createBuiltinToolHandlers, createBuiltinApprovalHandler } from './useAgent';\n\nexport type { UseAgentsResult } from './useAgents';\nexport type { UseChatOptions, UseChatResult } from './useChat';\nexport type { UseAgentOptions, UseAgentResult } from './useAgent';\n\n// Re-export types from core for convenience\nexport type {\n  DistriClientConfig,\n  DistriAgent,\n  DistriThread,\n  AgentCard,\n  Task,\n  Message,\n  TaskStatus,\n  MessageSendParams,\n  ExternalTool,\n  ToolCall,\n  MessageMetadata,\n  ApprovalMode,\n  InvokeConfig,\n  InvokeResult,\n  InvokeStreamResult,\n  ExternalToolHandler,\n  ApprovalHandler\n} from '@distri/core';\n\n// Re-export Agent class\nexport { Agent, DistriClient, APPROVAL_REQUEST_TOOL_NAME } from '@distri/core';"],"mappings":"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","names":["error","useState","useEffect","useState","error","useEffect","useState","useEffect","useCallback","useState","useCallback","useEffect","useState","useEffect","useCallback","useState","useCallback","useEffect","useState","useCallback","useRef","useState","useRef","useCallback","Agent","DistriClient"]}